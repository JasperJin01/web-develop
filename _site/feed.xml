<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-03T02:43:25+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">🏠 Jasper’s Blog</title><subtitle>Jasper&apos;s Blog(new version) since 2024.
</subtitle><author><name>Jasper Jin</name></author><entry><title type="html">代码快速复习</title><link href="http://localhost:4000/2024-03-21-coding_quick_review.html" rel="alternate" type="text/html" title="代码快速复习" /><published>2024-03-21T00:00:00+08:00</published><updated>2024-03-21T00:00:00+08:00</updated><id>http://localhost:4000/coding_quick_review</id><content type="html" xml:base="http://localhost:4000/2024-03-21-coding_quick_review.html"><![CDATA[<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Hello world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<ul id="markdown-toc">
  <li><a href="#c语言c复习" id="markdown-toc-c语言c复习">C语言（C++）复习</a>    <ul>
      <li><a href="#输入输出" id="markdown-toc-输入输出">输入输出</a></li>
      <li><a href="#字符串处理" id="markdown-toc-字符串处理">字符串处理</a></li>
      <li><a href="#文件io" id="markdown-toc-文件io">文件IO</a></li>
      <li><a href="#c-stl与库函数" id="markdown-toc-c-stl与库函数">C++ STL与库函数</a></li>
      <li><a href="#牛客网练习题链接" id="markdown-toc-牛客网练习题链接">牛客网练习题链接</a></li>
    </ul>
  </li>
  <li><a href="#练习题目" id="markdown-toc-练习题目">练习题目</a>    <ul>
      <li><a href="#判断是否为闰年" id="markdown-toc-判断是否为闰年">判断是否为闰年</a></li>
      <li><a href="#判断是否为质数-isprime" id="markdown-toc-判断是否为质数-isprime">判断是否为质数 IsPrime</a></li>
      <li><a href="#输出int整数的32位二进制" id="markdown-toc-输出int整数的32位二进制">输出int整数的32位二进制</a></li>
      <li><a href="#表达式求值" id="markdown-toc-表达式求值">表达式求值</a></li>
      <li><a href="#将数值去掉n位后返回最小的那个数" id="markdown-toc-将数值去掉n位后返回最小的那个数">将数值去掉n位后返回最小的那个数</a></li>
      <li><a href="#-图的算法" id="markdown-toc--图的算法">🔴 图的算法</a></li>
      <li><a href="#-动态规划回文子串的一些内容的复习" id="markdown-toc--动态规划回文子串的一些内容的复习">🔴 动态规划（回文子串）的一些内容的复习</a></li>
      <li><a href="#-分数转换成小数" id="markdown-toc--分数转换成小数">🔴 分数转换成小数</a></li>
    </ul>
  </li>
</ul>

<h1 id="c语言c复习">C语言（C++）复习</h1>

<p>如果可以使用C++，主要注意下面C语言用法：</p>

<ul>
  <li>C语言可以格式化输入<code class="language-plaintext highlighter-rouge">scanf("%d.%d.%d.%d", &amp;a, &amp;b, &amp;c, &amp;d);</code></li>
  <li>C语言可以格式化输出<code class="language-plaintext highlighter-rouge">printf("%03d\n", 7);</code></li>
  <li>多次获取值（适用于从文件读入）</li>
</ul>

<h2 id="输入输出">输入输出</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输入</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d.%d.%d.%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 例如输入 192.108.12.1,则abcd会输入为相应值</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> 			<span class="c1">// char str[50]; （没有地址符号）</span>
<span class="n">gets</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>					<span class="c1">// 输入一行字符串</span>
<span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> 			<span class="c1">// 输入一行字符串 string str;</span>
</code></pre></div></div>

<p><strong>注：使用getline获取一行的数据时，如果之前有输入过字符，会在缓冲区中留下回车符号。此时必须使用<code class="language-plaintext highlighter-rouge">getchar()</code>把缓冲区中的回车去掉。</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">ss</span><span class="p">,</span> <span class="n">sstest</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ss</span><span class="p">;</span>
	<span class="n">getchar</span><span class="p">();</span> <span class="c1">// 要把缓冲区中的回车去掉，没有这行代码sstest为空</span>
	<span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">sstest</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sstest: "</span> <span class="o">&lt;&lt;</span> <span class="n">sstest</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sstest's length: "</span> <span class="o">&lt;&lt;</span> <span class="n">sstest</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输出</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">127</span><span class="p">);</span>        <span class="c1">// 127</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%03d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>		<span class="c1">// 007</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">314</span><span class="p">.</span><span class="mi">15</span><span class="p">);</span>     <span class="c1">// 314.159000 （float类型）</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%.2f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">314</span><span class="p">.</span><span class="mi">15</span><span class="p">);</span>   <span class="c1">// 314.15 指定精度</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">314</span><span class="p">.</span><span class="mi">15</span><span class="p">);</span>    <span class="c1">// 314.159000 （double类型）</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">);</span>        <span class="c1">// c</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>        <span class="c1">// char str[50] （没有地址符号）</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%o</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">177</span><span class="p">);</span>        <span class="c1">// 177  八进制</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">177</span><span class="p">);</span>        <span class="c1">// b1   十六进制</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">314</span><span class="p">.</span><span class="mi">15</span><span class="p">);</span>     <span class="c1">// 3.141590e+02</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>Online Judge中连续多组测试数据的输入：</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">gets</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 输入一行字符串</span>
    <span class="c1">//...</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">str</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="字符串处理">字符串处理</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="c1">// 下面的函数在&lt;string.h&gt;头文件中</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="kt">char</span> <span class="n">str2</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">str2</span><span class="p">,</span> <span class="n">str1</span><span class="p">);</span> <span class="c1">// 把str1复制到str2中</span>
</code></pre></div></div>

<h2 id="文件io">文件IO</h2>

<p>（IO感觉真的不太常用），这里只介绍通过<code class="language-plaintext highlighter-rouge">fgetc(FILE*)</code>一个一个字符读取文件，通过<code class="language-plaintext highlighter-rouge">fputc(char, FILE*)</code>一个一个字符写入文件。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fileRead</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"文件路径"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">//以读(r)的方式打开文件</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 一个一个字符串读入</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
<span class="c1">// str：指向一个字符数组的指针，用于存储读取到的字符串。</span>
<span class="c1">// n：指明最多读取多少个字符，包括最后的空字符。为了安全读取整行，这个值应该是str指向的数组的大小。</span>
<span class="c1">// stream：指定从哪个文件流读取数据，通常是一个FILE *类型的文件指针。</span>

<span class="kt">void</span> <span class="nf">fileWrite</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">File</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"文件路径"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span> <span class="c1">// 以写(w)的方式打开文件，文件不存在会自动创建，文件存在会覆盖掉之前的内容</span>
    <span class="n">string</span> <span class="n">ss</span> <span class="o">=</span> <span class="s">"Input content..."</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">:</span> <span class="n">ss</span><span class="p">)</span> <span class="n">fputc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="c-stl与库函数">C++ STL与库函数</h2>

<p><code class="language-plaintext highlighter-rouge">stio()</code>和<code class="language-plaintext highlighter-rouge">to_string()</code></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// stack</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">;</span>
<span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
<span class="c1">// top()返回栈顶元素，pop()删除栈顶元素不返回值</span>
<span class="kt">int</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">num</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>


<span class="c1">// map</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">rev</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">')'</span><span class="p">,</span> <span class="sc">'('</span><span class="p">},{</span><span class="sc">']'</span><span class="p">,</span><span class="sc">'['</span><span class="p">},{</span><span class="sc">'}'</span><span class="p">,</span><span class="sc">'{'</span><span class="p">}</span> <span class="p">};</span> <span class="c1">// map可以使用这种方式初始化</span>

<span class="c1">// 用stack&lt;pair&lt;int, int&gt;&gt;保存图的邻接链表</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edge</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span> <span class="p">};</span>
	<span class="n">edge</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="mi">12</span><span class="p">,</span> <span class="mi">34</span><span class="p">});</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="牛客网练习题链接">牛客网练习题链接</h2>

<p>牛客网华中科技大学历年计算机考研复试上机题在线练习<a href="https://www.nowcoder.com/ta/hust-kaoyan">链接点这里</a>。</p>

<p>【PS】华中科技大学复试的机试环节，是将每道题目写好的代码放入指定的文件夹中保存在PC上，并非像LeetCode/牛客那样的线上测试评分。所以包括牛客网的题目，有些题目的测试数据也是不严谨的。</p>

<h1 id="练习题目">练习题目</h1>

<h2 id="判断是否为闰年">判断是否为闰年</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">%</span> <span class="mi">4</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="判断是否为质数-isprime">判断是否为质数 IsPrime</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<h2 id="输出int整数的32位二进制">输出int整数的32位二进制</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<h2 id="表达式求值">表达式求值</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">val</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">;</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">rev</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">')'</span><span class="p">,</span> <span class="sc">'('</span><span class="p">},{</span><span class="sc">']'</span><span class="p">,</span><span class="sc">'['</span><span class="p">},{</span><span class="sc">'}'</span><span class="p">,</span><span class="sc">'{'</span><span class="p">}</span> <span class="p">};</span> <span class="c1">// map可以使用这种方式初始化</span>
<span class="c1">// priority</span>
<span class="kt">int</span> <span class="nf">pri</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span><span class="sc">'%'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'^'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isOp</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span><span class="sc">'%'</span><span class="o">||</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'^'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mi</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">num1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">num1</span> <span class="o">*=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">num1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cal</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">num</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">num</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">+</span> <span class="n">tmp2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">*</span> <span class="n">tmp2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">/</span> <span class="n">tmp2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">%</span> <span class="n">tmp2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'^'</span><span class="p">)</span> <span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">mi</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">ss</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ss</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//输入a~f</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'f'</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 表示num</span>
			<span class="n">num</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">c</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'['</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'{'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isOp</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// TODO !这里一定不要忘记先判断一下栈是否为空！！</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pri</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="n">pri</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="n">cal</span><span class="p">();</span>
			<span class="n">op</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">rev</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">())</span> <span class="n">cal</span><span class="p">();</span>
			<span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">cal</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="将数值去掉n位后返回最小的那个数">将数值去掉n位后返回最小的那个数</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 取出num第index位数字后返回</span>
<span class="n">string</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
	<span class="n">string</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// a：输入的数，n：要删除的数字的数量</span>
<span class="kt">int</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">string</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">cur</span><span class="p">),</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">process</span><span class="p">(</span><span class="mi">692434354</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-图的算法">🔴 图的算法</h2>

<p>单源最短路（Dijkstra）</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">vis</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">path</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edge</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 初始化</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">;</span>
        <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">minDist</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">minDist</span> <span class="o">=</span>  <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
                <span class="n">path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>最小生成树</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Prim</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ldist</span><span class="p">;</span> <span class="c1">// 存储最小代价</span>
    <span class="k">struct</span> <span class="nc">EdgeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>

    <span class="c1">// 初始化</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lowcost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始时，MST中没有顶点</span>
        <span class="n">vex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 从顶点1开始构造MST</span>
    <span class="n">mark</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">lowcost</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">Head</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">VerAdj</span><span class="p">;</span>
        <span class="n">lowcost</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cost</span><span class="p">;</span>
        <span class="n">vex</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 构造MST的主循环</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ldist</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="c1">// 重置最小代价</span>
        <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 即将被访问的顶点</span>
        <span class="c1">// 确定即将被访问的顶点u</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">lowcost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ldist</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ldist</span> <span class="o">=</span> <span class="n">lowcost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 将顶点u加入MST</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到了有效的顶点</span>
            <span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="c1">// 更新与u相邻顶点到MST的最小代价</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">Head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">VerAdj</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">lowcost</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">lowcost</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cost</span><span class="p">;</span>
                    <span class="n">vex</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并查集</p>

<p>拓扑排序</p>

<h2 id="-动态规划回文子串的一些内容的复习">🔴 动态规划（回文子串）的一些内容的复习</h2>

<h2 id="-分数转换成小数">🔴 分数转换成小数</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">fractionToDecimal</span><span class="o">(</span><span class="kt">int</span> <span class="n">numerator</span><span class="o">,</span> <span class="kt">int</span> <span class="n">denominator</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numerator</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 分子为0，直接返回"0"</span>
        <span class="k">return</span> <span class="s">"0"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">string</span> <span class="n">result</span><span class="o">;</span>
    <span class="c1">// 如果结果为负数（异号），在结果前加上负号</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numerator</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">denominator</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="sc">'-'</span><span class="o">;</span>

    <span class="c1">// 使用long long类型避免溢出，并取绝对值</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="n">llabs</span><span class="o">(</span><span class="n">numerator</span><span class="o">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">llabs</span><span class="o">(</span><span class="n">denominator</span><span class="o">);</span>

    <span class="c1">// 计算整数部分，并将余数乘10准备计算小数部分</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">to_string</span><span class="o">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果能整除，直接返回整数部分</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 处理小数部分</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="sc">'.'</span><span class="o">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span> <span class="c1">// 用于记录余数出现的位置</span>

    <span class="c1">// 当余数不为0且该余数未出现过时，继续进行循环</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">remainder</span><span class="o">)</span> <span class="o">==</span> <span class="n">map</span><span class="o">.</span><span class="na">end</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">[</span><span class="n">remainder</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="c1">// 记录当前余数的位置</span>
        <span class="n">remainder</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// 余数乘10准备下一轮计算</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">to_string</span><span class="o">(</span><span class="n">remainder</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// 计算新的一位小数</span>
        <span class="n">remainder</span> <span class="o">%=</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// 更新余数</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 如果余数非0，说明发现了循环小数</span>
        <span class="c1">// 在循环开始的位置插入左括号，并在字符串末尾加上右括号</span>
        <span class="n">result</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">remainder</span><span class="o">],</span> <span class="s">"("</span><span class="o">);</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="sc">')'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jasper Jin</name></author><summary type="html"><![CDATA[#include &lt;stdio.h&gt; int main() { printf("Hello world!\n"); return 0; }]]></summary></entry><entry><title type="html">ChatGPT 提问汇总</title><link href="http://localhost:4000/2024-03-18-chatgpt.html" rel="alternate" type="text/html" title="ChatGPT 提问汇总" /><published>2024-03-18T00:00:00+08:00</published><updated>2024-03-18T00:00:00+08:00</updated><id>http://localhost:4000/chatgpt</id><content type="html" xml:base="http://localhost:4000/2024-03-18-chatgpt.html"><![CDATA[<h3 id="表达式求值处理负数情况">表达式求值（处理负数情况）</h3>

<p>你提到的代码在处理含有括号和负数的表达式时确实存在问题，特别是在处理类似<code class="language-plaintext highlighter-rouge">2*(-3)</code>这样的表达式时，它不能正确地处理负数。原因在于它没有专门处理一元运算符（如负号）的逻辑，使得程序在尝试将<code class="language-plaintext highlighter-rouge">-3</code>作为一个整体解析时出现错误。此外，代码中没有直接处理空格，可能会影响表达式的正确解析。</p>

<p>为了修复这个问题，我们需要增加一些逻辑来处理一元运算符，尤其是在遇到<code class="language-plaintext highlighter-rouge">(</code>后面紧跟着的<code class="language-plaintext highlighter-rouge">-</code>号时，我们可以将其视为一元运算符，并且在解析到一元运算符时，应当正确地将其应用到紧随其后的数字上。一种方法是在解析到这种情况时，将负号和紧随其后的数字一起作为一个负数处理。</p>

<p>下面是修改后的代码，包括对处理一元运算符的支持：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">isOp</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'%'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'^'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">isDigit</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">cal</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'*'</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'/'</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'%'</span><span class="p">:</span> <span class="k">return</span> <span class="n">fmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="k">case</span> <span class="sc">'^'</span><span class="p">:</span> <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="nl">default:</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">string</span> <span class="nf">inToPost</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">infix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">post</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">;</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">pri</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'+'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="sc">'-'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="sc">'*'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'/'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'%'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'^'</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">rev</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">')'</span><span class="p">,</span> <span class="sc">'('</span><span class="p">},</span> <span class="p">{</span><span class="sc">']'</span><span class="p">,</span> <span class="sc">'['</span><span class="p">},</span> <span class="p">{</span><span class="sc">'}'</span><span class="p">,</span> <span class="sc">'{'</span><span class="p">}</span> <span class="err">`</span><span class="p">};</span>

    <span class="c1">// 处理负号的方法</span>
    <span class="k">auto</span> <span class="n">handleNegative</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post</span><span class="p">](</span><span class="kt">bool</span> <span class="n">isUnaryMinus</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isUnaryMinus</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果是一元运算符（负号）</span>
            <span class="n">post</span> <span class="o">+=</span> <span class="s">"0 "</span><span class="p">;</span> <span class="c1">// 向后缀表达式中添加0，以便用0减去后面的数</span>
        <span class="p">}</span>
        <span class="n">op</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">'-'</span><span class="p">);</span> <span class="c1">// 将减号作为二元运算符处理</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="n">prevIsOp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 前一个字符是否是运算符或左括号，用于识别一元运算符</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">infix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">infix</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 忽略空格</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isDigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">prevIsOp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">infix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">isDigit</span><span class="p">(</span><span class="n">infix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">||</span> <span class="n">infix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="n">infix</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
            <span class="o">--</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'['</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'{'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prevIsOp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">op</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isOp</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">&amp;&amp;</span> <span class="n">prevIsOp</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 处理一元负号</span>
                <span class="n">handleNegative</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pri</span><span class="p">[</span><span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">pri</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">post</span> <span class="o">+=</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                    <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
                    <span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">op</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="n">prevIsOp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'}'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="n">rev</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
                <span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// Pop the opening bracket</span>
            <span class="n">prevIsOp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">post</span> <span class="o">+=</span> <span class="n">op</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
        <span class="n">op</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">post</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">evaluatePostfix</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">postfix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">num</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">postfix</span>

</code></pre></div></div>

<p>用更简单的C++语法对关键的处理逻辑进行修改。我们将重点修改<code class="language-plaintext highlighter-rouge">inToPost</code>函数，以处理一元负号的情况，同时尽量减少对现代C++特性的使用。这里，我们将简化处理，具体地，在遇到一个负号时，需要判断它是作为一元运算符（即负号）还是二元运算符（减号）。</p>

<p>为了处理这个问题，我们可以引入一个额外的标志变量，用来标记当前是否可能遇到一元运算符。具体来说，如果负号出现在表达式的开始位置或者一个左括号之后，我们可以认为它是一元运算符。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">inToPost</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">infix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">post</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">opStack</span><span class="p">;</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'+'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="sc">'-'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="sc">'*'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'/'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'%'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'^'</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>

    <span class="kt">bool</span> <span class="n">mayBeUnary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 初始时可能遇到一元运算符</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">infix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isDigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">post</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">mayBeUnary</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 数字之后不可能是一元运算符</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 忽略空格</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isOp</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">&amp;&amp;</span> <span class="n">mayBeUnary</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 处理一元负号</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="s">"0 "</span><span class="p">;</span> <span class="c1">// 表达式前添加0</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">opStack</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">precedence</span><span class="p">[</span><span class="n">opStack</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">precedence</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="n">opStack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">opStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
            <span class="n">opStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">mayBeUnary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 运算符后可能遇到一元运算符</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">opStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">mayBeUnary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 左括号后可能遇到一元运算符</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">opStack</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">opStack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
                <span class="n">post</span> <span class="o">+=</span> <span class="n">opStack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">opStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">opStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 弹出左括号</span>
            <span class="n">mayBeUnary</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 右括号后不可能是一元运算符</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">opStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">post</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
        <span class="n">post</span> <span class="o">+=</span> <span class="n">opStack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">opStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">post</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="高精度除法模拟">高精度除法模拟</h3>

<p>高精度除法模拟通常指的是在处理超出标准数据类型（如<code class="language-plaintext highlighter-rouge">int</code>，<code class="language-plaintext highlighter-rouge">long long</code>等）范围的大数进行除法运算时，通过模拟手工除法的过程来实现。这种方法通常涉及到字符串处理或者数组来表示大数，逐位或逐段地进行计算。下面提供一个简化的高精度除法（大数除以小数）的实现示例，使用C++编写。这个例子中，大数使用字符串表示，被除数可以是一个较大的数，而除数是一个int范围内的数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cppCopy code
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// 高精度除法：大数（字符串表示）除以小数（int表示），返回商（字符串表示）
string highPrecisionDivision(string dividend, int divisor) {
    string result; // 存储结果
    int index = 0; // 处理到dividend的哪一位
    int temp = dividend[index] - '0'; // 当前处理的数
    while (temp &lt; divisor) {
        temp = temp * 10 + (dividend[++index] - '0');
    }
    
    while (dividend.size() &gt; index) {
        result += (temp / divisor) + '0'; // 计算当前位的结果，并转换为字符
        temp = (temp % divisor) * 10 + dividend[++index] - '0';
    }

    // 移除结果前面的0
    while (result[0] == '0' &amp;&amp; result.length() != 1) {
        result.erase(0, 1);
    }

    return result.length() == 0 ? "0" : result;
}

int main() {
    string dividend;
    int divisor;
    cout &lt;&lt; "Enter the dividend (big number): ";
    cin &gt;&gt; dividend;
    cout &lt;&lt; "Enter the divisor (small number): ";
    cin &gt;&gt; divisor;

    string quotient = highPrecisionDivision(dividend, divisor);
    cout &lt;&lt; "Quotient: " &lt;&lt; quotient &lt;&lt; endl;

    return 0;
}
</code></pre></div></div>

<p>这段代码实现了大数（使用字符串表示）除以小数（使用<code class="language-plaintext highlighter-rouge">int</code>表示）的功能。它通过模拟手工除法的方式，从左到右逐位处理被除数，计算每一步的商，并将结果累加到结果字符串中。需要注意的是，这个实现假设除数是一个正整数，且没有处理除法的余数部分。如果需要处理更复杂的情况（如负数，或者需要余数等），则需要对代码进行相应的扩展。</p>

<h3 id="账户合并">账户合并</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">fa</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">fa</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">fa</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fu</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">fa</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">fv</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fa</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fu</span> <span class="o">!=</span> <span class="n">fv</span><span class="p">)</span> <span class="n">fa</span><span class="p">[</span><span class="n">fv</span><span class="p">]</span> <span class="o">=</span> <span class="n">fu</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">accountsMerge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">accounts</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">emailToName</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">emailToId</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 用于给每个邮箱分配一个唯一的ID</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">account</span> <span class="o">:</span> <span class="n">accounts</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span> <span class="o">=</span> <span class="n">account</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">account</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emailToId</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">account</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="n">emailToId</span><span class="p">[</span><span class="n">account</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">emailToName</span><span class="p">[</span><span class="n">account</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fa</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">account</span> <span class="o">:</span> <span class="n">accounts</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">firstId</span> <span class="o">=</span> <span class="n">emailToId</span><span class="p">[</span><span class="n">account</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">account</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">merge</span><span class="p">(</span><span class="n">firstId</span><span class="p">,</span> <span class="n">emailToId</span><span class="p">[</span><span class="n">account</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">fa</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 使用map来归类和排序同一用户的所有邮箱</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">email</span> <span class="o">:</span> <span class="n">emailToId</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">email</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">fa</span><span class="p">);</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">email</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 构建最终答案</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">mergedAccounts</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">account</span><span class="p">;</span>
            <span class="n">account</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">emailToName</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span> <span class="c1">// 添加用户名</span>
            <span class="n">sort</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">email</span> <span class="o">:</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">account</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">email</span><span class="p">);</span> <span class="c1">// 添加邮箱</span>
            <span class="p">}</span>
            <span class="n">mergedAccounts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">account</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">mergedAccounts</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h3 id="最长公共子串longest-common-substring">最长公共子串（Longest Common Substring）</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cppCopy code
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

// 查找最长公共子串
string longestCommonSubstring(const string&amp; s1, const string&amp; s2) {
    int m = s1.length(), n = s2.length();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    int maxLength = 0, endPos = 0; // maxLength记录最长公共子串的长度，endPos记录结束位置

    for (int i = 1; i &lt;= m; ++i) {
        for (int j = 1; j &lt;= n; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] &gt; maxLength) {
                    maxLength = dp[i][j];
                    endPos = i - 1; // 更新最长公共子串的结束位置
                }
            }
        }
    }

    return s1.substr(endPos - maxLength + 1, maxLength);
}

int main() {
    string s1 = "abcde";
    string s2 = "babc";
    cout &lt;&lt; "Longest Common Substring: " &lt;&lt; longestCommonSubstring(s1, s2) &lt;&lt; endl;
    return 0;
}
</code></pre></div></div>

<h3 id="最长回文子串longest-palindromic-substring">最长回文子串（Longest Palindromic Substring）</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cppCopy code
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

// 查找最长回文子串
string longestPalindromicSubstring(const string&amp; s) {
    int n = s.length();
    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));
    int start = 0, maxLength = 1; // start记录最长回文子串的起始位置，maxLength记录长度

    for (int i = 0; i &lt; n; ++i) {
        dp[i][i] = true; // 单个字符是回文
    }

    for (int i = 0; i &lt; n - 1; ++i) {
        if (s[i] == s[i + 1]) {
            dp[i][i + 1] = true; // 相邻字符相同是回文
            start = i;
            maxLength = 2;
        }
    }

    for (int len = 3; len &lt;= n; ++len) { // len是当前检查的子串长度
        for (int i = 0; i &lt;= n - len; ++i) {
            int j = i + len - 1; // 子串结束位置
            if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) {
                dp[i][j] = true;
                start = i;
                maxLength = len;
            }
        }
    }

    return s.substr(start, maxLength);
}

int main() {
    string s = "babad";
    cout &lt;&lt; "Longest Palindromic Substring: " &lt;&lt; longestPalindromicSubstring(s) &lt;&lt; endl;
    return 0;
}
</code></pre></div></div>

<p>这两个动态规划的解法都是基于子问题的解来构建整体问题的解，从而达到降低时间复杂度的目的。最长公共子串问题的动态规划解法时间复杂度和空间复杂度都是<code class="language-plaintext highlighter-rouge">O(m*n)</code>，其中<code class="language-plaintext highlighter-rouge">m</code>和<code class="language-plaintext highlighter-rouge">n</code>分别是输入的两个字符串的长度。最长回文子串问题的动态规划解法时间复杂度也是<code class="language-plaintext highlighter-rouge">O(n^2)</code>，空间复杂度同样是<code class="language-plaintext highlighter-rouge">O(n^2)</code>，其中<code class="language-plaintext highlighter-rouge">n</code>是输入字符串的长度。</p>

<h3 id="1-r--s的等价关系代数表达式求解过程">1. R ÷ S的等价关系代数表达式求解过程</h3>

<p>假设我们有两个表R(A, B, C)和S(B, C, D)。我们要找的是R ÷ S的结果，即在R中找到所有与S中所有(B, C)组合都存在关系的A值。这个过程可以分解为以下步骤：</p>

<ol>
  <li><strong>投影</strong>：首先，对R和S分别进行投影，去除不需要比较的属性。对于R，我们只关心(A, B, C)，所以保持不变；对于S，我们也只关心(B, C)，所以对S做投影π(B, C)(S)。</li>
  <li><strong>笛卡尔积和差集</strong>：接下来，我们需要找出R中存在而在S中没有的(B, C)组合。这可以通过将R与S的投影做笛卡尔积，然后从R中的(B, C)投影中减去这个结果得到。这个步骤实际上是在寻找R中有但S中没有的(B, C)组合，但这不是除法操作的直接结果，需要进一步的处理。</li>
  <li><strong>差集</strong>：为了得到最终结果，我们需要再次利用差集。这次，我们从R中所有可能的(A)中减去那些在步骤2中找到的与S中(B, C)不匹配的(A)。这样，剩下的就是在R中与S中所有(B, C)都存在关系的A值。</li>
</ol>

<p>综上所述，一个较为接近的等价关系代数表达式可能是这样的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>πA(R) - πA( ( πA,B,C(R) × πB,C(S) ) - R )
</code></pre></div></div>

<p>但是，请注意，这个表达式并不完全精确对应于除法操作的标准定义，因为关系代数的除法操作是通过比较找出“完全匹配”的元组，而上述步骤更多的是一个概念上的解释，用于理解除法操作的效果。</p>

<h3 id="2-最长递增子序列的思路">2. 最长递增子序列的思路</h3>

<p>最长递增子序列（Longest Increasing Subsequence, LIS）问题可以通过几种不同的方法解决，每种方法的时间复杂度略有不同。下面介绍两种常见的方法：</p>

<h4 id="动态规划dp">动态规划（DP）</h4>

<p>动态规划是解决LIS问题的经典方法，时间复杂度为O(n^2)。</p>

<ul>
  <li>初始化一个长度等于原数组长度的dp数组，dp[i]存储以第i个元素结尾的最长递增子序列的长度。</li>
  <li>遍历数组，对于每个元素nums[i]，再次遍历其之前的所有元素nums[j] (0 ≤ j &lt; i)。</li>
  <li>如果nums[i] &gt; nums[j]，则nums[i]可以跟在nums[j]构成的递增子序列之后，此时更新dp[i] = max(dp[i], dp[j] + 1)。</li>
  <li>最后，dp数组中的最大值即为整个数组的最长递增子序列的长度。</li>
</ul>

<h4 id="二分查找贪心">二分查找+贪心</h4>

<p>这个方法的时间复杂度是O(n log n)，通过贪心策略加上二分查找来优化。</p>

<ul>
  <li>维护一个数组tails，其中tails[i]存储长度为i+1的所有递增子序列中末尾最小的元素。</li>
  <li>遍历原数组，对于每个元素x，用二分查找在tails中找到第一个大于或等于x的元素，如果找到，更新它；如果没有找到，将x追加到tails末尾。</li>
  <li>遍历结束时，tails的长度即为最长递增子序列的长度。</li>
</ul>

<p>两种方法中，动态规划更容易理解和实现，适合大</p>

<h3 id="汇编代码">汇编代码</h3>

<ol>
  <li>写出把10号功能调用的IP和CS存储到自变量INTTEN_CS和INTTEN_IP的代码段</li>
</ol>

<p>这里似乎是在谈论实模式下的汇编语言编程，特别是与中断有关的内容。10号功能调用听起来像是中断调用（比如，BIOS中断），但“存储到自变量INTTEN_CS和INTTEN_IP的代码段”具体要做的是在软件层面记录中断处理程序的CS（代码段寄存器）和IP（指令指针寄存器）值。</p>

<p>对于这个问题的解释，需要注意的是，在现代计算机架构中，直接操作IP和CS寄存器的情况很少，因为这涉及到操作系统级别的底层操作，通常是通过操作系统提供的API或者特定语言构造来实现。而且，直接操作这些寄存器通常是在汇编语言中进行的。在实模式下，可以通过软件中断调用来实现某些功能，但是直接获取中断向量的CS和IP值并存储它们，通常不是标准操作。</p>

<p>对于具体实现，如果是在DOS或类似环境下，一般会通过编写汇编程序来直接访问中断向量表（位于内存的低地址处）来获取某个中断处理程序的段地址（CS）和偏移地址（IP）。但这样的操作在现代操作系统中通常不被允许或需要特权。</p>

<p>在汇编语言中，要获取并存储某个中断号（如10号中断）的中断处理程序地址，通常需要访问中断向量表。中断向量表位于实模式内存的最低端，每个向量占用4个字节，前两个字节是偏移地址（IP），后两个字节是段地址（CS）。由于这是一个实模式的示例，我们将使用x86汇编语言，并假设使用的是DOS或类似环境。</p>

<p>下面是一个示例代码，用于获取10号中断（比如视频中断）的CS和IP值，并存储到<code class="language-plaintext highlighter-rouge">INTTEN_CS</code>和<code class="language-plaintext highlighter-rouge">INTTEN_IP</code>这两个字变量中：</p>

<pre><code class="language-assembly">Copy code
; 假设 INTTEN_CS 和 INTTEN_IP 已经定义在数据段中
; 假设数据段已经正确初始化

MOV AX, 0     ; 清零AX寄存器，用于后续操作
MOV ES, AX    ; 将ES段寄存器设置为0，指向中断向量表的开始
MOV BX, 4*10  ; 计算10号中断向量的内存偏移量（每个向量4个字节）

; 获取10号中断的IP值（向量的前两个字节）
MOV AX, [ES:BX]
MOV INTTEN_IP, AX

; 获取10号中断的CS值（向量的后两个字节）
MOV AX, [ES:BX+2]
MOV INTTEN_CS, AX
</code></pre>

<p>请注意，实际使用时需要根据你的环境和具体要求调整代码，尤其是如何定义和使用<code class="language-plaintext highlighter-rouge">INTTEN_CS</code>和<code class="language-plaintext highlighter-rouge">INTTEN_IP</code>这两个变量。在现代操作系统中，直接操作硬件和中断向量表可能受到限制，该代码主要适用于DOS或其他实模式环境。</p>

<h3 id="数组中出现次数不低于n2的数">数组中出现次数不低于[n/2]的数</h3>

<p>这个问题可以通过摩尔投票法解决，时间复杂度为O(n)，空间复杂度为O(1)。摩尔投票法是通过一系列的对抗消除，找出数组中出现次数超过一半的元素。</p>

<p>以下是用C++实现的代码：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">majorityElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 验证candidate是否确实是出现次数超过一半</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 如果没有找到，则返回-1或者其他标识</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Majority Element: "</span> <span class="o">&lt;&lt;</span> <span class="n">majorityElement</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="r--s的等价关系代数表达式">R ÷ S的等价关系代数表达式</h3>

<p>关系代数的除法运算R ÷ S用于找出R中所有与S中所有元组都有关系的元组。等价的关系代数表达式较为复杂，需要通过多步骤构建，主要思路是：</p>

<ol>
  <li><strong>投影</strong>R和S关系中相关属性；</li>
  <li><strong>笛卡尔积</strong>操作，然后<strong>选择</strong>出符合条件的元组；</li>
  <li><strong>差集</strong>操作，找出只在R中出现而未完全与S匹配的元组；</li>
  <li>再次<strong>投影</strong>以去除额外的属性，得到最终结果。</li>
</ol>

<p>关系代数的除法R ÷ S用来找出能与S中所有元组匹配的R中的元组。一个直观的等价表达式涉及到差集和笛卡尔积操作。假设<code class="language-plaintext highlighter-rouge">R(A, B)</code>和<code class="language-plaintext highlighter-rouge">S(B)</code>，其中A和B表示属性列，我们要找的是所有在R中但不需要在S中出现的A值。</p>

<p>不过，直接写出等价的关系代数表达式相对复杂，需要结合具体的例子和上下文。一种简化的思路是首先对R按B做投影，然后从结果中减去（即差集）那些在与S做笛卡尔积后不能完全覆盖R的元组。但这个过程需要具体的步骤和实现，依赖于具体数据库和查询语言的功能，因此在此不易直接给出一个一般性的表达式。</p>

<p>理解除法操作最重要的是掌握其目的：找出与另一关系中所有元组都有关系的元组集合。具体实现通常需要结合其他操作，如投影、选择、差集等，来构造等价查询。</p>]]></content><author><name>Jasper Jin</name></author><summary type="html"><![CDATA[表达式求值（处理负数情况）]]></summary></entry><entry><title type="html">项目笔记——Video Downloader&amp;amp;Python语法学习</title><link href="http://localhost:4000/2024-02-11-python.html" rel="alternate" type="text/html" title="项目笔记——Video Downloader&amp;amp;Python语法学习" /><published>2024-02-11T00:00:00+08:00</published><updated>2024-02-11T00:00:00+08:00</updated><id>http://localhost:4000/python</id><content type="html" xml:base="http://localhost:4000/2024-02-11-python.html"><![CDATA[<h3 id="python环境与配置">python环境与配置</h3>

<ol>
  <li>
    <p>使用<code class="language-plaintext highlighter-rouge">conda activate &lt;myenv&gt;</code>更换terminal中的环境。</p>

    <p>Python程序中，使用<code class="language-plaintext highlighter-rouge">import sys</code>，<code class="language-plaintext highlighter-rouge">print(sys.executable)</code>打印环境。</p>

    <p>终端中使用<code class="language-plaintext highlighter-rouge">which python</code>查看python路径，<code class="language-plaintext highlighter-rouge">python --version</code>查看python版本。</p>
  </li>
  <li>
    <p>import的路径</p>
  </li>
</ol>

<h3 id="python语法">python语法</h3>

<ol>
  <li>
    <p>python类中函数的命名规范：</p>

    <ul>
      <li>
        <p>函数名一律小写，若有多个单词用下划线隔开；双下划线 <code class="language-plaintext highlighter-rouge">__</code> 开头的方法或属性默认是私有的，只能在类的内部被访问</p>
      </li>
      <li>
        <p>变量名最好小写，若有多个使用下划线分开；常量使用全大写，多个单词使用下划线隔开 。</p>
      </li>
    </ul>
  </li>
  <li></li>
  <li><code class="language-plaintext highlighter-rouge">from rich.console import Console</code>：用于打印文本到控制台，可以添加样式和高亮显示</li>
  <li>
    <p>`    encode = “UTF-8-SIG” if system() == “Windows” else “UTF-8” `：”UTF-8-SIG” 在UTF-8基础上，文件的开头包含了一个特殊的字节顺序标记（BOM）。BOM用于一些Windows应用程序，帮助它们正确地解释UTF-8编码的文本。</p>
  </li>
  <li></li>
  <li></li>
</ol>]]></content><author><name>Jasper Jin</name></author><summary type="html"><![CDATA[python环境与配置]]></summary></entry><entry><title type="html">Using Footnotes</title><link href="http://localhost:4000/jekyll/2023-12-12-footnotes.html" rel="alternate" type="text/html" title="Using Footnotes" /><published>2023-12-12T00:00:00+08:00</published><updated>2023-12-12T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/footnotes</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-12-12-footnotes.html"><![CDATA[<p>This jekyll-theme supports <a href="https://www.mathjax.org/">MathJax</a> to render footnotes
in markdown.</p>

<p>e.g.,</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The well known Pythagorean theorem $x^2 + y^2 = z^2$ was
proved to be invalid for other exponents[^1].
Meaning the next equation has no integer solutions:

$$ x^n + y^n = z^n $$
</code></pre></div></div>

<p>The well known Pythagorean theorem $x^2 + y^2 = z^2$ was
proved to be invalid for other exponents<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.
Meaning the next equation has no integer solutions:</p>

\[x^n + y^n = z^n\]

<h2 id="long-contents">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1">Sub title 1</h3>

<h3 id="sub-title-2">Sub title 2</h3>

<h3 id="sub-title-3">Sub title 3</h3>

<h2 id="long-contents-1">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1-1">Sub title 1</h3>

<h3 id="sub-title-2-1">Sub title 2</h3>

<h3 id="sub-title-3-1">Sub title 3</h3>

<h2 id="long-contents-2">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1-2">Sub title 1</h3>

<h3 id="sub-title-2-2">Sub title 2</h3>

<h3 id="sub-title-3-2">Sub title 3</h3>

<h2 id="long-contents-3">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1-3">Sub title 1</h3>

<h3 id="sub-title-2-3">Sub title 2</h3>

<h3 id="sub-title-3-3">Sub title 3</h3>

<h2 id="long-contents-4">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1-4">Sub title 1</h3>

<h3 id="sub-title-2-4">Sub title 2</h3>

<h3 id="sub-title-3-4">Sub title 3</h3>

<h2 id="long-contents-5">Long contents</h2>

<p>long contents …..</p>

<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
</ol>

<h3 id="sub-title-1-5">Sub title 1</h3>

<h3 id="sub-title-2-5">Sub title 2</h3>

<h3 id="sub-title-3-5">Sub title 3</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem">https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[This jekyll-theme supports MathJax to render footnotes in markdown.]]></summary></entry><entry><title type="html">MathJax and LaTeX</title><link href="http://localhost:4000/jekyll/2023-10-14-math-latex.html" rel="alternate" type="text/html" title="MathJax and LaTeX" /><published>2023-10-14T00:00:00+08:00</published><updated>2023-10-14T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/math-latex</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-10-14-math-latex.html"><![CDATA[<p>This jekyll-theme supports <a href="https://www.mathjax.org/">MathJax</a> to render $\LaTeX$
and mathematics expressions.</p>

<blockquote class="block-tip">
  <h5 id="tip">TIP</h5>

  <p>Currently, Kramdown uses double dollar sign delimiters for inline and display math:
<a href="https://kramdown.gettalong.org/syntax.html#math-blocks">https://kramdown.gettalong.org/syntax.html#math-blocks</a>.</p>
</blockquote>

<p>e.g.,</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The well known Pythagorean theorem $x^2 + y^2 = z^2$ was
proved to be invalid for other exponents.
Meaning the next equation has no integer solutions:

$$ x^n + y^n = z^n $$
</code></pre></div></div>

<p>The well known Pythagorean theorem $x^2 + y^2 = z^2$ was
proved to be invalid for other exponents.
Meaning the next equation has no integer solutions:</p>

\[x^n + y^n = z^n\]

<p>Another example with more complex markups:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>When $a <span class="se">\n</span>e 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are

$$x = {-b <span class="se">\p</span>m <span class="se">\s</span>qrt{b^2-4ac} <span class="se">\o</span>ver 2a}.$$
</code></pre></div></div>

<p>When $a \ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are</p>

\[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]

<p>Refer to the <a href="https://docs.mathjax.org/en/latest/index.html">MathJax website</a> for more examples.</p>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[This jekyll-theme supports MathJax to render $\LaTeX$ and mathematics expressions.]]></summary></entry><entry><title type="html">Diagrams with mermaid.js</title><link href="http://localhost:4000/jekyll/2023-08-31-mermaid.html" rel="alternate" type="text/html" title="Diagrams with mermaid.js" /><published>2023-08-31T00:00:00+08:00</published><updated>2023-08-31T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/mermaid</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-08-31-mermaid.html"><![CDATA[<p>This jekyll-theme supports <a href="https://mermaid.js.org/">mermaid.js</a> to render diagrams
in markdown.</p>

<p>To enable the mermaid support, you need to set <code class="language-plaintext highlighter-rouge">mermaid: true</code> in the front matter
of your post.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">title</span><span class="pi">:</span> <span class="s">Diagrams with mermaid.js</span>
<span class="na">date</span><span class="pi">:</span> <span class="s">2023-08-31</span>
<span class="na">layout</span><span class="pi">:</span> <span class="s">post</span>
<span class="na">mermaid</span><span class="pi">:</span> <span class="kc">true</span>
<span class="nn">---</span>
</code></pre></div></div>

<p>Then you can use mermaid syntax in your markdown:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre></div></div>

<pre><code class="language-mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>

<p>Or, even some complex examples:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</code></pre></div></div>

<pre><code class="language-mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</code></pre>

<p>Refer to the <a href="https://mermaid.js.org/intro/">mermaid.js website</a> for more examples.</p>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[This jekyll-theme supports mermaid.js to render diagrams in markdown.]]></summary></entry><entry><title type="html">Tips, Warnings, and Dangers</title><link href="http://localhost:4000/jekyll/2022-06-30-tips_warnings_dangers.html" rel="alternate" type="text/html" title="Tips, Warnings, and Dangers" /><published>2022-06-30T00:00:00+08:00</published><updated>2022-06-30T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/tips_warnings_dangers</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-06-30-tips_warnings_dangers.html"><![CDATA[<p>This jekyll-theme supports tips, warnings, and dangers blocks and the style is referred
from <a href="https://discordjs.guide/popular-topics/canvas.html#setting-up-napi-rs-canvas">the discord.js website</a>.</p>

<p>You could have the following <a href="https://kramdown.gettalong.org/quickref.html#block-attributes">markdown attributes (supported by kramdown)</a>:</p>

<h3 id="tips">Tips</h3>

<p>Using a <code class="language-plaintext highlighter-rouge">{: .block-tip}</code> attribute:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gt">&gt; ##### TIP</span>
<span class="gt">&gt;</span>
<span class="gt">&gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have</span>
<span class="gt">&gt; this or a similar version after installation.</span>
{: .block-tip }
</code></pre></div></div>

<blockquote class="block-tip">
  <h5 id="tip">TIP</h5>

  <p>This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have
this or a similar version after installation.</p>
</blockquote>

<h3 id="warnings">Warnings</h3>

<p>Using a <code class="language-plaintext highlighter-rouge">{: .block-warning}</code> attribute:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gt">&gt; ##### WARNING</span>
<span class="gt">&gt;</span>
<span class="gt">&gt; Be sure that you're familiar with things like async/await and object destructuring</span>
<span class="gt">&gt; before continuing, as we'll be making use of features like these.</span>
{: .block-warning }
</code></pre></div></div>

<blockquote class="block-warning">
  <h5 id="warning">WARNING</h5>

  <p>Be sure that you’re familiar with things like async/await and object destructuring
before continuing, as we’ll be making use of features like these.</p>
</blockquote>

<h3 id="dangers">Dangers</h3>

<p>Using a <code class="language-plaintext highlighter-rouge">{: .block-danger}</code> attribute:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gt">&gt; ##### DANGER</span>
<span class="gt">&gt;</span>
<span class="gt">&gt; You cannot delete an ephemeral message.</span>
{: .block-danger }
</code></pre></div></div>

<blockquote class="block-danger">
  <h5 id="danger">DANGER</h5>

  <p>You cannot delete an ephemeral message.</p>
</blockquote>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[This jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website.]]></summary></entry><entry><title type="html">Wide tables</title><link href="http://localhost:4000/jekyll/2022-06-26-wide_tables.html" rel="alternate" type="text/html" title="Wide tables" /><published>2022-06-26T00:00:00+08:00</published><updated>2022-06-26T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/wide_tables</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-06-26-wide_tables.html"><![CDATA[<p>A wide tables needs to be wrapped into a <code class="language-plaintext highlighter-rouge">div</code> with class <code class="language-plaintext highlighter-rouge">table-wrapper</code>
to make sure it displayed as expected on mobile devices. For example,</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"table-wrapper"</span> <span class="na">markdown=</span><span class="s">"block"</span><span class="nt">&gt;</span>

|title1|title2|title3|title4|title5|title6|title7|title8|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|2|3|4|5|6|7|8|
|1|2|3|4|5|6|7|8|
|1|2|3|4|5|6|7|8|
|1|2|3|4|5|6|7|8|

<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Will be rendered as</p>

<div class="table-wrapper">

  <table>
    <thead>
      <tr>
        <th style="text-align: center">title1</th>
        <th style="text-align: center">title2</th>
        <th style="text-align: center">title3</th>
        <th style="text-align: center">title4</th>
        <th style="text-align: center">title5</th>
        <th style="text-align: center">title6</th>
        <th style="text-align: center">title7</th>
        <th style="text-align: center">title8</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: center">1</td>
        <td style="text-align: center">2</td>
        <td style="text-align: center">3</td>
        <td style="text-align: center">4</td>
        <td style="text-align: center">5</td>
        <td style="text-align: center">6</td>
        <td style="text-align: center">7</td>
        <td style="text-align: center">8</td>
      </tr>
      <tr>
        <td style="text-align: center">1</td>
        <td style="text-align: center">2</td>
        <td style="text-align: center">3</td>
        <td style="text-align: center">4</td>
        <td style="text-align: center">5</td>
        <td style="text-align: center">6</td>
        <td style="text-align: center">7</td>
        <td style="text-align: center">8</td>
      </tr>
      <tr>
        <td style="text-align: center">1</td>
        <td style="text-align: center">2</td>
        <td style="text-align: center">3</td>
        <td style="text-align: center">4</td>
        <td style="text-align: center">5</td>
        <td style="text-align: center">6</td>
        <td style="text-align: center">7</td>
        <td style="text-align: center">8</td>
      </tr>
      <tr>
        <td style="text-align: center">1</td>
        <td style="text-align: center">2</td>
        <td style="text-align: center">3</td>
        <td style="text-align: center">4</td>
        <td style="text-align: center">5</td>
        <td style="text-align: center">6</td>
        <td style="text-align: center">7</td>
        <td style="text-align: center">8</td>
      </tr>
    </tbody>
  </table>

</div>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[A wide tables needs to be wrapped into a div with class table-wrapper to make sure it displayed as expected on mobile devices. For example,]]></summary></entry><entry><title type="html">Page with cover image</title><link href="http://localhost:4000/jekyll/2022-05-24-page_cover.html" rel="alternate" type="text/html" title="Page with cover image" /><published>2022-05-24T00:00:00+08:00</published><updated>2022-05-24T00:00:00+08:00</updated><id>http://localhost:4000/jekyll/page_cover</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-05-24-page_cover.html"><![CDATA[<p>The jekyll-gitbook theme supports adding a cover image to a specific page by adding
a <code class="language-plaintext highlighter-rouge">cover</code> field to the page metadata:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ---
  title: Page with cover image
  author: Tao He
  date: 2022-05-24
  category: Jekyll
  layout: post
<span class="gi">+ cover: /assets/jekyll-gitbook/dinosaur.gif
</span>  ---
</code></pre></div></div>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata:]]></summary></entry></feed>