{"/chapter01/SpringBootStudy01.html": {
    "title": "Spring Boot 01",
    "keywords": "",
    "url": "/chapter01/SpringBootStudy01.html",
    "body": "==Spring Boot集成第三方类库的步骤== 通过maven引入springboot-XXXX-starter 修改yaml或properties全局统一配置文件 加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。 Artifact ==application.properties改成application.yml（pom.xml和这些东西是一个意思吗？是一个含义吗？）=="
  },"/2024-03-21-coding_quick_review.html": {
    "title": "代码快速复习",
    "keywords": "",
    "url": "/2024-03-21-coding_quick_review.html",
    "body": "#include &lt;stdio.h&gt; int main() { printf(\"Hello world!\\n\"); return 0; } C语言（C++）复习 输入输出 字符串处理 文件IO C++ STL与库函数 牛客网练习题链接 练习题目 判断是否为闰年 判断是否为质数 IsPrime 输出int整数的32位二进制 表达式求值 将数值去掉n位后返回最小的那个数 🔴 图的算法 🔴 动态规划（回文子串）的一些内容的复习 🔴 分数转换成小数 C语言（C++）复习 如果可以使用C++，主要注意下面C语言用法： C语言可以格式化输入scanf(\"%d.%d.%d.%d\", &amp;a, &amp;b, &amp;c, &amp;d); C语言可以格式化输出printf(\"%03d\\n\", 7); 多次获取值（适用于从文件读入） 输入输出 // 输入 scanf(\"%d\", &amp;a); scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); scanf(\"%d.%d.%d.%d\", &amp;a, &amp;b, &amp;c, &amp;d); // 例如输入 192.108.12.1,则abcd会输入为相应值 scanf(\"%s\", str); // char str[50]; （没有地址符号） gets(str); // 输入一行字符串 getline(cin, str); // 输入一行字符串 string str; 注：使用getline获取一行的数据时，如果之前有输入过字符，会在缓冲区中留下回车符号。此时必须使用getchar()把缓冲区中的回车去掉。 #include &lt;iostream&gt; using namespace std; int main(int argc, char *argv[]) { string ss, sstest; cin &gt;&gt; ss; getchar(); // 要把缓冲区中的回车去掉，没有这行代码sstest为空 getline(cin, sstest); cout &lt;&lt; \"sstest: \" &lt;&lt; sstest &lt;&lt; endl; cout &lt;&lt; \"sstest's length: \" &lt;&lt; sstest.length() &lt;&lt; endl; } // 输出 printf(\"%d\\n\", 127); // 127 printf(\"%03d\\n\", 7); // 007 printf(\"%f\\n\", 314.15); // 314.159000 （float类型） printf(\"%.2f\\n\", 314.15); // 314.15 指定精度 printf(\"%lf\\n\", 314.15); // 314.159000 （double类型） printf(\"%c\\n\", 'c'); // c printf(\"%s\\n\", str); // char str[50] （没有地址符号） printf(\"%o\\n\", 177); // 177 八进制 printf(\"%x\\n\", 177); // b1 十六进制 printf(\"%e\\n\", 314.15); // 3.141590e+02 Online Judge中连续多组测试数据的输入： while (scanf(\"%d\", &amp;num) != EOF) { //... } while (gets(str)) { // 输入一行字符串 //... } while (cin &gt;&gt; a &gt;&gt; b) { //... } while (getline(cin, str)) { //... } 字符串处理 char str[50]; scanf(\"%s\", str); printf(\"%s\\n\", str); // 下面的函数在&lt;string.h&gt;头文件中 printf(\"%d\\n\", strlen(str)); char str2[50]; strcpy(str2, str1); // 把str1复制到str2中 文件IO （IO感觉真的不太常用），这里只介绍通过fgetc(FILE*)一个一个字符读取文件，通过fputc(char, FILE*)一个一个字符写入文件。 void fileRead() { FILE* fp = fopen(\"文件路径\", \"r\"); //以读(r)的方式打开文件 char ch; while((ch = fgetc(fp)) != EOF) { // 一个一个字符串读入 // ... } fclose(fp); } char *fgets(char *str, int n, FILE *stream); // str：指向一个字符数组的指针，用于存储读取到的字符串。 // n：指明最多读取多少个字符，包括最后的空字符。为了安全读取整行，这个值应该是str指向的数组的大小。 // stream：指定从哪个文件流读取数据，通常是一个FILE *类型的文件指针。 void fileWrite() { File* fp = fopen(\"文件路径\", \"w\"); // 以写(w)的方式打开文件，文件不存在会自动创建，文件存在会覆盖掉之前的内容 string ss = \"Input content...\"; for (char c: ss) fputc(c, fp); fclose(fp); } C++ STL与库函数 stio()和to_string() // stack stack&lt;int&gt; num; num.push(9); // top()返回栈顶元素，pop()删除栈顶元素不返回值 int tmp1 = num.top(); num.pop(); // map map&lt;char,char&gt; rev = { {')', '('},{']','['},{'}','{'} }; // map可以使用这种方式初始化 // 用stack&lt;pair&lt;int, int&gt;&gt;保存图的邻接链表 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;pair&lt;int, int&gt;&gt; edge = { {1,2}, {3,4}, {5,6} }; edge.push_back({12, 34}); for (int i = 0; i &lt; edge.size(); i++) cout &lt;&lt; edge[i].first &lt;&lt; \" \" &lt;&lt; edge[i].second &lt;&lt; endl; } 牛客网练习题链接 牛客网华中科技大学历年计算机考研复试上机题在线练习链接点这里。 【PS】华中科技大学复试的机试环节，是将每道题目写好的代码放入指定的文件夹中保存在PC上，并非像LeetCode/牛客那样的线上测试评分。所以包括牛客网的题目，有些题目的测试数据也是不严谨的。 练习题目 判断是否为闰年 (year % 400 == 0) || (year % 100!=0 &amp;&amp; year % 4==0) 判断是否为质数 IsPrime 输出int整数的32位二进制 表达式求值 #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;map&gt; using namespace std; int val[6]; stack&lt;int&gt; num; stack&lt;char&gt; op; map&lt;char,char&gt; rev = { {')', '('},{']','['},{'}','{'} }; // map可以使用这种方式初始化 // priority int pri(char c) { if (c == '+' || c == '-') return 1; if (c == '*' || c == '/' || c =='%') return 2; if (c == '^') return 3; return -1; } int isOp(char c) { return c == '+' || c == '-' ||c == '*' || c == '/' || c =='%'||c == '^'; } int mi(int num1, int num2) { int tmp = num1; for (int i = 0; i &lt; num2 - 1; i++) num1 *= tmp; return num1; } void cal() { int tmp2 = num.top(); num.pop(); int tmp1 = num.top(); num.pop(); char c = op.top(); op.pop(); if (c == '+') num.push(tmp1 + tmp2); else if (c == '-') num.push(tmp1 - tmp2); else if (c == '*') num.push(tmp1 * tmp2); else if (c == '/') num.push(tmp1 / tmp2); else if (c == '%') num.push(tmp1 % tmp2); else if (c == '^') num.push(mi(tmp1, tmp2)); } int main() { string ss; cin &gt;&gt; ss; for (int i = 0; i &lt; 6; i++) cin &gt;&gt; val[i]; //输入a~f for (char c : ss) { if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') { // 表示num num.push(val[c-'a']); } else if (c == '(' || c == '[' || c == '{') { op.push(c); } else if (isOp(c)) { // TODO !这里一定不要忘记先判断一下栈是否为空！！ while (!op.empty() &amp;&amp; pri(op.top()) &gt;= pri(c)) cal(); op.push(c); } else { while (rev[c] != op.top()) cal(); op.pop(); } } while (!op.empty()) cal(); cout &lt;&lt; num.top(); } 将数值去掉n位后返回最小的那个数 #include &lt;iostream&gt; using namespace std; // 取出num第index位数字后返回 string remove(int num, int index) { string ss = to_string(num); string res; for (int i = 0; i &lt; index; i++) res.push_back(ss[i]); for (int i = index+1; i &lt; ss.length(); i++) res.push_back(ss[i]); return res; } // a：输入的数，n：要删除的数字的数量 int process(int a, int n) { if (n == 0) return a; string ss = to_string(a); int res = 0x3f3f3f3f; for (int i = 0; i &lt; ss.length(); i++) { string cur = remove(a, i); int tmp = process(stoi(cur), n-1); res = min(res, tmp); } return res; } int main() { cout &lt;&lt; process(692434354, 5); } 🔴 图的算法 单源最短路（Dijkstra） int vis[n]; int dist[n]; int path[n]; vector&lt;pair&lt;int, int&gt;&gt; edge; void dijkstra(int v) { // 初始化 for (int i = 0; i &lt; n; i++) { vis[i] = 0; dist[i] = MAX; path[i] = -1; } dist[v] = 0; for (int j = 0; j &lt; n; j++) { int u = 0; int minDist = MAX; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; minDist &gt; dist[i]) { u = i; minDist = dist[i]; } } vis[u] = 1; for (int i = 0; i &lt; edge[u].size(); i++) { int v = edge[u][i].first, cost = edge[u][i].second; if (dist[v] &gt; dist[u] + cost) { dist[v] = dist[u] + cost; path[v] = u; } } } } 最小生成树 void Prim() { int i, j, k, u; int ldist; // 存储最小代价 struct EdgeNode* p; // 初始化 for (i = 1; i &lt;= n; i++) { lowcost[i] = INF; mark[i] = 0; // 初始时，MST中没有顶点 vex[i] = -1; } // 从顶点1开始构造MST mark[1] = 1; lowcost[1] = 0; for (p = Head[1]; p != NULL; p = p-&gt;link) { k = p-&gt;VerAdj; lowcost[k] = p-&gt;cost; vex[k] = 1; } // 构造MST的主循环 for (j = 1; j &lt; n; j++) { ldist = INF; // 重置最小代价 u = -1; // 即将被访问的顶点 // 确定即将被访问的顶点u for (i = 1; i &lt;= n; i++) { if (!mark[i] &amp;&amp; lowcost[i] &lt; ldist) { ldist = lowcost[i]; u = i; } } // 将顶点u加入MST if (u != -1) { // 找到了有效的顶点 mark[u] = 1; // 更新与u相邻顶点到MST的最小代价 for (p = Head[u]; p != NULL; p = p-&gt;link) { k = p-&gt;VerAdj; if (!mark[k] &amp;&amp; p-&gt;cost &lt; lowcost[k]) { lowcost[k] = p-&gt;cost; vex[k] = u; } } } } } 并查集 拓扑排序 🔴 动态规划（回文子串）的一些内容的复习 🔴 分数转换成小数 string fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { // 分子为0，直接返回\"0\" return \"0\"; } string result; // 如果结果为负数（异号），在结果前加上负号 if (numerator &lt; 0 ^ denominator &lt; 0) result += '-'; // 使用long long类型避免溢出，并取绝对值 long long a = llabs(numerator), b = llabs(denominator); // 计算整数部分，并将余数乘10准备计算小数部分 result += to_string(a / b); long long remainder = a % b; if (remainder == 0) { // 如果能整除，直接返回整数部分 return result; } // 处理小数部分 result += '.'; unordered_map&lt;long long, int&gt; map; // 用于记录余数出现的位置 // 当余数不为0且该余数未出现过时，继续进行循环 while (remainder != 0 &amp;&amp; map.find(remainder) == map.end()) { map[remainder] = result.size(); // 记录当前余数的位置 remainder *= 10; // 余数乘10准备下一轮计算 result += to_string(remainder / b); // 计算新的一位小数 remainder %= b; // 更新余数 } if (remainder != 0) { // 如果余数非0，说明发现了循环小数 // 在循环开始的位置插入左括号，并在字符串末尾加上右括号 result.insert(map[remainder], \"(\"); result += ')'; } return result; }"
  },"/2024-03-18-chatgpt.html": {
    "title": "ChatGPT 提问汇总",
    "keywords": "",
    "url": "/2024-03-18-chatgpt.html",
    "body": "表达式求值（处理负数情况） 你提到的代码在处理含有括号和负数的表达式时确实存在问题，特别是在处理类似2*(-3)这样的表达式时，它不能正确地处理负数。原因在于它没有专门处理一元运算符（如负号）的逻辑，使得程序在尝试将-3作为一个整体解析时出现错误。此外，代码中没有直接处理空格，可能会影响表达式的正确解析。 为了修复这个问题，我们需要增加一些逻辑来处理一元运算符，尤其是在遇到(后面紧跟着的-号时，我们可以将其视为一元运算符，并且在解析到一元运算符时，应当正确地将其应用到紧随其后的数字上。一种方法是在解析到这种情况时，将负号和紧随其后的数字一起作为一个负数处理。 下面是修改后的代码，包括对处理一元运算符的支持： #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; bool isOp(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^'; } bool isDigit(char c) { return isdigit(c) || c == '.'; } double cal(double a, double b, char op) { switch (op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; case '%': return fmod(a, b); case '^': return pow(a, b); default: return 0; } } string inToPost(const string&amp; infix) { string post; stack&lt;char&gt; op; map&lt;char, int&gt; pri = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'%', 2}, {'^', 3} }; map&lt;char, char&gt; rev = { {')', '('}, {']', '['}, {'}', '{'} `}; // 处理负号的方法 auto handleNegative = [&amp;op, &amp;post](bool isUnaryMinus) { if (isUnaryMinus) { // 如果是一元运算符（负号） post += \"0 \"; // 向后缀表达式中添加0，以便用0减去后面的数 } op.push('-'); // 将减号作为二元运算符处理 }; bool prevIsOp = true; // 前一个字符是否是运算符或左括号，用于识别一元运算符 for (int i = 0; i &lt; infix.size(); ++i) { char c = infix[i]; if (c == ' ') continue; // 忽略空格 if (isDigit(c)) { prevIsOp = false; while (i &lt; infix.size() &amp;&amp; (isDigit(infix[i]) || infix[i] == '.')) { post += infix[i++]; } post += ' '; --i; } else if (c == '(' || c == '[' || c == '{') { prevIsOp = true; op.push(c); } else if (isOp(c)) { if (c == '-' &amp;&amp; prevIsOp) { // 处理一元负号 handleNegative(true); } else { while (!op.empty() &amp;&amp; pri[op.top()] &gt;= pri[c]) { post += op.top(); post += ' '; op.pop(); } op.push(c); prevIsOp = true; } } else if (c == ')' || c == ']' || c == '}') { while (!op.empty() &amp;&amp; op.top() != rev[c]) { post += op.top(); post += ' '; op.pop(); } op.pop(); // Pop the opening bracket prevIsOp = false; } } while (!op.empty()) { post += op.top(); post += ' '; op.pop(); } return post; } double evaluatePostfix(const string&amp; postfix) { stack&lt;double&gt; values; string num; for (char c : postfix 用更简单的C++语法对关键的处理逻辑进行修改。我们将重点修改inToPost函数，以处理一元负号的情况，同时尽量减少对现代C++特性的使用。这里，我们将简化处理，具体地，在遇到一个负号时，需要判断它是作为一元运算符（即负号）还是二元运算符（减号）。 为了处理这个问题，我们可以引入一个额外的标志变量，用来标记当前是否可能遇到一元运算符。具体来说，如果负号出现在表达式的开始位置或者一个左括号之后，我们可以认为它是一元运算符。 string inToPost(const string&amp; infix) { string post; stack&lt;char&gt; opStack; map&lt;char, int&gt; precedence = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'%', 2}, {'^', 3} }; bool mayBeUnary = true; // 初始时可能遇到一元运算符 for (char c : infix) { if (isDigit(c)) { post += c; mayBeUnary = false; // 数字之后不可能是一元运算符 } else if (c == ' ') { // 忽略空格 } else if (isOp(c)) { if (c == '-' &amp;&amp; mayBeUnary) { // 处理一元负号 post += \"0 \"; // 表达式前添加0 } while (!opStack.empty() &amp;&amp; precedence[opStack.top()] &gt;= precedence[c]) { post += ' '; post += opStack.top(); opStack.pop(); } post += ' '; opStack.push(c); mayBeUnary = true; // 运算符后可能遇到一元运算符 } else if (c == '(') { opStack.push(c); mayBeUnary = true; // 左括号后可能遇到一元运算符 } else if (c == ')') { while (!opStack.empty() &amp;&amp; opStack.top() != '(') { post += ' '; post += opStack.top(); opStack.pop(); } if (!opStack.empty()) opStack.pop(); // 弹出左括号 mayBeUnary = false; // 右括号后不可能是一元运算符 } } while (!opStack.empty()) { post += ' '; post += opStack.top(); opStack.pop(); } return post; } 高精度除法模拟 高精度除法模拟通常指的是在处理超出标准数据类型（如int，long long等）范围的大数进行除法运算时，通过模拟手工除法的过程来实现。这种方法通常涉及到字符串处理或者数组来表示大数，逐位或逐段地进行计算。下面提供一个简化的高精度除法（大数除以小数）的实现示例，使用C++编写。这个例子中，大数使用字符串表示，被除数可以是一个较大的数，而除数是一个int范围内的数。 cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; // 高精度除法：大数（字符串表示）除以小数（int表示），返回商（字符串表示） string highPrecisionDivision(string dividend, int divisor) { string result; // 存储结果 int index = 0; // 处理到dividend的哪一位 int temp = dividend[index] - '0'; // 当前处理的数 while (temp &lt; divisor) { temp = temp * 10 + (dividend[++index] - '0'); } while (dividend.size() &gt; index) { result += (temp / divisor) + '0'; // 计算当前位的结果，并转换为字符 temp = (temp % divisor) * 10 + dividend[++index] - '0'; } // 移除结果前面的0 while (result[0] == '0' &amp;&amp; result.length() != 1) { result.erase(0, 1); } return result.length() == 0 ? \"0\" : result; } int main() { string dividend; int divisor; cout &lt;&lt; \"Enter the dividend (big number): \"; cin &gt;&gt; dividend; cout &lt;&lt; \"Enter the divisor (small number): \"; cin &gt;&gt; divisor; string quotient = highPrecisionDivision(dividend, divisor); cout &lt;&lt; \"Quotient: \" &lt;&lt; quotient &lt;&lt; endl; return 0; } 这段代码实现了大数（使用字符串表示）除以小数（使用int表示）的功能。它通过模拟手工除法的方式，从左到右逐位处理被除数，计算每一步的商，并将结果累加到结果字符串中。需要注意的是，这个实现假设除数是一个正整数，且没有处理除法的余数部分。如果需要处理更复杂的情况（如负数，或者需要余数等），则需要对代码进行相应的扩展。 账户合并 class Solution { public: int find(int v, vector&lt;int&gt;&amp; fa) { if (v == fa[v]) return v; else return fa[v] = find(fa[v], fa); } void merge(int u, int v, vector&lt;int&gt;&amp; fa) { int fu = find(u, fa); int fv = find(v, fa); if (fu != fv) fa[fv] = fu; } vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) { map&lt;string, string&gt; emailToName; map&lt;string, int&gt; emailToId; int count = 0; // 用于给每个邮箱分配一个唯一的ID for (auto&amp; account : accounts) { string&amp; name = account[0]; for (int i = 1; i &lt; account.size(); i++) { if (!emailToId.count(account[i])) { emailToId[account[i]] = count++; emailToName[account[i]] = name; } } } vector&lt;int&gt; fa(count); for (int i = 0; i &lt; count; i++) fa[i] = i; for (auto&amp; account : accounts) { int firstId = emailToId[account[1]]; for (int i = 2; i &lt; account.size(); i++) { merge(firstId, emailToId[account[i]], fa); } } // 使用map来归类和排序同一用户的所有邮箱 map&lt;int, vector&lt;string&gt;&gt; ans; for (auto&amp; email : emailToId) { int root = find(email.second, fa); ans[root].push_back(email.first); } // 构建最终答案 vector&lt;vector&lt;string&gt;&gt; mergedAccounts; for (auto&amp; p : ans) { vector&lt;string&gt; account; account.push_back(emailToName[p.second[0]]); // 添加用户名 sort(p.second.begin(), p.second.end()); for (auto&amp; email : p.second) { account.push_back(email); // 添加邮箱 } mergedAccounts.push_back(account); } return mergedAccounts; } }; 最长公共子串（Longest Common Substring） cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 查找最长公共子串 string longestCommonSubstring(const string&amp; s1, const string&amp; s2) { int m = s1.length(), n = s2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); int maxLength = 0, endPos = 0; // maxLength记录最长公共子串的长度，endPos记录结束位置 for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (s1[i - 1] == s2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &gt; maxLength) { maxLength = dp[i][j]; endPos = i - 1; // 更新最长公共子串的结束位置 } } } } return s1.substr(endPos - maxLength + 1, maxLength); } int main() { string s1 = \"abcde\"; string s2 = \"babc\"; cout &lt;&lt; \"Longest Common Substring: \" &lt;&lt; longestCommonSubstring(s1, s2) &lt;&lt; endl; return 0; } 最长回文子串（Longest Palindromic Substring） cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 查找最长回文子串 string longestPalindromicSubstring(const string&amp; s) { int n = s.length(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); int start = 0, maxLength = 1; // start记录最长回文子串的起始位置，maxLength记录长度 for (int i = 0; i &lt; n; ++i) { dp[i][i] = true; // 单个字符是回文 } for (int i = 0; i &lt; n - 1; ++i) { if (s[i] == s[i + 1]) { dp[i][i + 1] = true; // 相邻字符相同是回文 start = i; maxLength = 2; } } for (int len = 3; len &lt;= n; ++len) { // len是当前检查的子串长度 for (int i = 0; i &lt;= n - len; ++i) { int j = i + len - 1; // 子串结束位置 if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) { dp[i][j] = true; start = i; maxLength = len; } } } return s.substr(start, maxLength); } int main() { string s = \"babad\"; cout &lt;&lt; \"Longest Palindromic Substring: \" &lt;&lt; longestPalindromicSubstring(s) &lt;&lt; endl; return 0; } 这两个动态规划的解法都是基于子问题的解来构建整体问题的解，从而达到降低时间复杂度的目的。最长公共子串问题的动态规划解法时间复杂度和空间复杂度都是O(m*n)，其中m和n分别是输入的两个字符串的长度。最长回文子串问题的动态规划解法时间复杂度也是O(n^2)，空间复杂度同样是O(n^2)，其中n是输入字符串的长度。 1. R ÷ S的等价关系代数表达式求解过程 假设我们有两个表R(A, B, C)和S(B, C, D)。我们要找的是R ÷ S的结果，即在R中找到所有与S中所有(B, C)组合都存在关系的A值。这个过程可以分解为以下步骤： 投影：首先，对R和S分别进行投影，去除不需要比较的属性。对于R，我们只关心(A, B, C)，所以保持不变；对于S，我们也只关心(B, C)，所以对S做投影π(B, C)(S)。 笛卡尔积和差集：接下来，我们需要找出R中存在而在S中没有的(B, C)组合。这可以通过将R与S的投影做笛卡尔积，然后从R中的(B, C)投影中减去这个结果得到。这个步骤实际上是在寻找R中有但S中没有的(B, C)组合，但这不是除法操作的直接结果，需要进一步的处理。 差集：为了得到最终结果，我们需要再次利用差集。这次，我们从R中所有可能的(A)中减去那些在步骤2中找到的与S中(B, C)不匹配的(A)。这样，剩下的就是在R中与S中所有(B, C)都存在关系的A值。 综上所述，一个较为接近的等价关系代数表达式可能是这样的： πA(R) - πA( ( πA,B,C(R) × πB,C(S) ) - R ) 但是，请注意，这个表达式并不完全精确对应于除法操作的标准定义，因为关系代数的除法操作是通过比较找出“完全匹配”的元组，而上述步骤更多的是一个概念上的解释，用于理解除法操作的效果。 2. 最长递增子序列的思路 最长递增子序列（Longest Increasing Subsequence, LIS）问题可以通过几种不同的方法解决，每种方法的时间复杂度略有不同。下面介绍两种常见的方法： 动态规划（DP） 动态规划是解决LIS问题的经典方法，时间复杂度为O(n^2)。 初始化一个长度等于原数组长度的dp数组，dp[i]存储以第i个元素结尾的最长递增子序列的长度。 遍历数组，对于每个元素nums[i]，再次遍历其之前的所有元素nums[j] (0 ≤ j &lt; i)。 如果nums[i] &gt; nums[j]，则nums[i]可以跟在nums[j]构成的递增子序列之后，此时更新dp[i] = max(dp[i], dp[j] + 1)。 最后，dp数组中的最大值即为整个数组的最长递增子序列的长度。 二分查找+贪心 这个方法的时间复杂度是O(n log n)，通过贪心策略加上二分查找来优化。 维护一个数组tails，其中tails[i]存储长度为i+1的所有递增子序列中末尾最小的元素。 遍历原数组，对于每个元素x，用二分查找在tails中找到第一个大于或等于x的元素，如果找到，更新它；如果没有找到，将x追加到tails末尾。 遍历结束时，tails的长度即为最长递增子序列的长度。 两种方法中，动态规划更容易理解和实现，适合大 汇编代码 写出把10号功能调用的IP和CS存储到自变量INTTEN_CS和INTTEN_IP的代码段 这里似乎是在谈论实模式下的汇编语言编程，特别是与中断有关的内容。10号功能调用听起来像是中断调用（比如，BIOS中断），但“存储到自变量INTTEN_CS和INTTEN_IP的代码段”具体要做的是在软件层面记录中断处理程序的CS（代码段寄存器）和IP（指令指针寄存器）值。 对于这个问题的解释，需要注意的是，在现代计算机架构中，直接操作IP和CS寄存器的情况很少，因为这涉及到操作系统级别的底层操作，通常是通过操作系统提供的API或者特定语言构造来实现。而且，直接操作这些寄存器通常是在汇编语言中进行的。在实模式下，可以通过软件中断调用来实现某些功能，但是直接获取中断向量的CS和IP值并存储它们，通常不是标准操作。 对于具体实现，如果是在DOS或类似环境下，一般会通过编写汇编程序来直接访问中断向量表（位于内存的低地址处）来获取某个中断处理程序的段地址（CS）和偏移地址（IP）。但这样的操作在现代操作系统中通常不被允许或需要特权。 在汇编语言中，要获取并存储某个中断号（如10号中断）的中断处理程序地址，通常需要访问中断向量表。中断向量表位于实模式内存的最低端，每个向量占用4个字节，前两个字节是偏移地址（IP），后两个字节是段地址（CS）。由于这是一个实模式的示例，我们将使用x86汇编语言，并假设使用的是DOS或类似环境。 下面是一个示例代码，用于获取10号中断（比如视频中断）的CS和IP值，并存储到INTTEN_CS和INTTEN_IP这两个字变量中： Copy code ; 假设 INTTEN_CS 和 INTTEN_IP 已经定义在数据段中 ; 假设数据段已经正确初始化 MOV AX, 0 ; 清零AX寄存器，用于后续操作 MOV ES, AX ; 将ES段寄存器设置为0，指向中断向量表的开始 MOV BX, 4*10 ; 计算10号中断向量的内存偏移量（每个向量4个字节） ; 获取10号中断的IP值（向量的前两个字节） MOV AX, [ES:BX] MOV INTTEN_IP, AX ; 获取10号中断的CS值（向量的后两个字节） MOV AX, [ES:BX+2] MOV INTTEN_CS, AX 请注意，实际使用时需要根据你的环境和具体要求调整代码，尤其是如何定义和使用INTTEN_CS和INTTEN_IP这两个变量。在现代操作系统中，直接操作硬件和中断向量表可能受到限制，该代码主要适用于DOS或其他实模式环境。 数组中出现次数不低于[n/2]的数 这个问题可以通过摩尔投票法解决，时间复杂度为O(n)，空间复杂度为O(1)。摩尔投票法是通过一系列的对抗消除，找出数组中出现次数超过一半的元素。 以下是用C++实现的代码： #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; int majorityElement(vector&lt;int&gt;&amp; nums) { int count = 0; int candidate = 0; for (int num : nums) { if (count == 0) { candidate = num; } count += (num == candidate) ? 1 : -1; } // 验证candidate是否确实是出现次数超过一半 count = 0; for (int num : nums) { if (num == candidate) count++; } if (count &gt; nums.size() / 2) return candidate; return -1; // 如果没有找到，则返回-1或者其他标识 } int main() { vector&lt;int&gt; nums = {2, 2, 1, 1, 1, 2, 2}; cout &lt;&lt; \"Majority Element: \" &lt;&lt; majorityElement(nums) &lt;&lt; endl; return 0; } R ÷ S的等价关系代数表达式 关系代数的除法运算R ÷ S用于找出R中所有与S中所有元组都有关系的元组。等价的关系代数表达式较为复杂，需要通过多步骤构建，主要思路是： 投影R和S关系中相关属性； 笛卡尔积操作，然后选择出符合条件的元组； 差集操作，找出只在R中出现而未完全与S匹配的元组； 再次投影以去除额外的属性，得到最终结果。 关系代数的除法R ÷ S用来找出能与S中所有元组匹配的R中的元组。一个直观的等价表达式涉及到差集和笛卡尔积操作。假设R(A, B)和S(B)，其中A和B表示属性列，我们要找的是所有在R中但不需要在S中出现的A值。 不过，直接写出等价的关系代数表达式相对复杂，需要结合具体的例子和上下文。一种简化的思路是首先对R按B做投影，然后从结果中减去（即差集）那些在与S做笛卡尔积后不能完全覆盖R的元组。但这个过程需要具体的步骤和实现，依赖于具体数据库和查询语言的功能，因此在此不易直接给出一个一般性的表达式。 理解除法操作最重要的是掌握其目的：找出与另一关系中所有元组都有关系的元组集合。具体实现通常需要结合其他操作，如投影、选择、差集等，来构造等价查询。"
  },"/2024-02-11-python.html": {
    "title": "项目笔记——Video Downloader&amp;Python语法学习",
    "keywords": "",
    "url": "/2024-02-11-python.html",
    "body": "python环境与配置 使用conda activate &lt;myenv&gt;更换terminal中的环境。 Python程序中，使用import sys，print(sys.executable)打印环境。 终端中使用which python查看python路径，python --version查看python版本。 import的路径 python语法 python类中函数的命名规范： 函数名一律小写，若有多个单词用下划线隔开；双下划线 __ 开头的方法或属性默认是私有的，只能在类的内部被访问 变量名最好小写，若有多个使用下划线分开；常量使用全大写，多个单词使用下划线隔开 。 from rich.console import Console：用于打印文本到控制台，可以添加样式和高亮显示 ` encode = “UTF-8-SIG” if system() == “Windows” else “UTF-8” `：”UTF-8-SIG” 在UTF-8基础上，文件的开头包含了一个特殊的字节顺序标记（BOM）。BOM用于一些Windows应用程序，帮助它们正确地解释UTF-8编码的文本。"
  },"/jekyll/2023-12-12-footnotes.html": {
    "title": "Using Footnotes",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-12-12-footnotes.html",
    "body": "This jekyll-theme supports MathJax to render footnotes in markdown. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents[^1]. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents1. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem &#8617;"
  },"/jekyll/2023-10-14-math-latex.html": {
    "title": "MathJax and LaTeX",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-10-14-math-latex.html",
    "body": "This jekyll-theme supports MathJax to render $\\LaTeX$ and mathematics expressions. TIP Currently, Kramdown uses double dollar sign delimiters for inline and display math: https://kramdown.gettalong.org/syntax.html#math-blocks. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Another example with more complex markups: When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are \\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\] Refer to the MathJax website for more examples."
  },"/jekyll/2023-08-31-mermaid.html": {
    "title": "Diagrams with mermaid.js",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-08-31-mermaid.html",
    "body": "This jekyll-theme supports mermaid.js to render diagrams in markdown. To enable the mermaid support, you need to set mermaid: true in the front matter of your post. --- title: Diagrams with mermaid.js date: 2023-08-31 layout: post mermaid: true --- Then you can use mermaid syntax in your markdown: graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; Or, even some complex examples: sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! Refer to the mermaid.js website for more examples."
  },"/jekyll/2022-06-30-tips_warnings_dangers.html": {
    "title": "Tips, Warnings, and Dangers",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-30-tips_warnings_dangers.html",
    "body": "This jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website. You could have the following markdown attributes (supported by kramdown): Tips Using a {: .block-tip} attribute: &gt; ##### TIP &gt; &gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have &gt; this or a similar version after installation. {: .block-tip } TIP This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have this or a similar version after installation. Warnings Using a {: .block-warning} attribute: &gt; ##### WARNING &gt; &gt; Be sure that you're familiar with things like async/await and object destructuring &gt; before continuing, as we'll be making use of features like these. {: .block-warning } WARNING Be sure that you’re familiar with things like async/await and object destructuring before continuing, as we’ll be making use of features like these. Dangers Using a {: .block-danger} attribute: &gt; ##### DANGER &gt; &gt; You cannot delete an ephemeral message. {: .block-danger } DANGER You cannot delete an ephemeral message."
  },"/jekyll/2022-06-26-wide_tables.html": {
    "title": "Wide tables",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-26-wide_tables.html",
    "body": "A wide tables needs to be wrapped into a div with class table-wrapper to make sure it displayed as expected on mobile devices. For example, &lt;div class=\"table-wrapper\" markdown=\"block\"&gt; |title1|title2|title3|title4|title5|title6|title7|title8| |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| &lt;/div&gt; Will be rendered as title1 title2 title3 title4 title5 title6 title7 title8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8"
  },"/jekyll/2022-05-24-page_cover.html": {
    "title": "Page with cover image",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-05-24-page_cover.html",
    "body": "The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata: --- title: Page with cover image author: Tao He date: 2022-05-24 category: Jekyll layout: post + cover: /assets/jekyll-gitbook/dinosaur.gif ---"
  },"/research/02-transform.html": {
    "title": "Transformer的学习（2）",
    "keywords": "",
    "url": "/research/02-transform.html",
    "body": ""
  },"/research/01-transform.html": {
    "title": "Transformer的学习（1）",
    "keywords": "",
    "url": "/research/01-transform.html",
    "body": "李宏毅 Self-attention 李宏毅老师《机器学习》课程笔记-4.1 Self-attention1（写了很多东西，挺干货的。包括最重要的attention计算过程）。 Attention核心思想 Attention核心思想2：Attention的思想如同它的名字一样，就是“注意力”，在预测结果时把注意力放在不同的特征上。 举个例子。比如在预测“我妈今天做的这顿饭真好吃”的情感时，如果只预测正向还是负向，那真正影响结果的只有“真好吃”这三个字，前面说的“我妈今天做的这顿饭”基本没什么用，如果是直接对token embedding进行平均去求句子表示会引入不少噪声。所以引入attention机制，让我们可以根据任务目标赋予输入token不同的权重，理想情况下前半句的权重都在0.0及，后三个字则是“0.3, 0.3, 0.3”，在计算句子表示时就变成了： 最终表示 = 0.01x我+0.01x妈+0.01x今+0.01x天+0.01x做+0.01x的+0.01x这+0.01x顿+0.02x饭+0.3x真+0.3x好+0.3x吃 怎么用知道了，那核心就在于这个权重怎么计算。通常我们会将输入分为query(Q), key(K), value(V)三种： 先用Q和K计算权重$\\alpha$，会用softmax对权重归一化： $\\alpha = softmax(f(QK))$ 再用权重对结果加权： $out = \\Sigma \\alpha_i * V_i$ 上文中QK的具体运算f有多种方法，常见的有加性attention和乘性attention： $f(Q.K) = tanh(W_1Q + W_2K)$ $f(Q,K) = QK^T$ 再深入理解下去，这种机制其实做的是寻址（addressing），也就是模仿中央处理器与存储交互的方式将存储的内容读出来，可以看一下李宏毅老师的课程。 Transformer模型原理 https://zhuanlan.zhihu.com/p/521380855 &#8617; https://zhuanlan.zhihu.com/p/43493999 这篇文章后面还介绍了attention在NLP中最早的应用：Seq2seq+attention。 &#8617;"
  }}
