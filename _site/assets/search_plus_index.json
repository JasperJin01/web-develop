{"/pages/vehicle/vehicle/": {
    "title": "🚙 Vehicle",
    "keywords": "Jekyll",
    "url": "/pages/vehicle/vehicle/",
    "body": "This is an contact page. ddddd"
  },"/pages/weekly_report/": {
    "title": "📝 Weekly Report",
    "keywords": "Jekyll",
    "url": "/pages/weekly_report/",
    "body": "Week 3: Jan 15-21, 2024"
  },"/pages/assemble/": {
    "title": "华中科技大学考研复试 汇编语言笔记",
    "keywords": "Jekyll",
    "url": "/pages/assemble/",
    "body": "基础知识（寻址方式、指令） 乘法指令（MUL,IMUL）==MUL和IMUL语法和要求都是一样的吧？== MUL OPS MUL OP MUL 除法指令 寻址方式与基础 常见寄存器： 通用寄存器：EAX、EBX、ECX、EDX——双字/4字节；AX、BX等——单字/2字节；AX拆分为AH和AL（H high 高字节，L low 低字节） 段寄存器：CS、DS、ES等。代码段寄存器CS不能赋值，其他寄存器可以赋字字寄存器，不能赋立即数/段地址/段名。例：MOV DS, DATA ❌DATA是段名；MOV DS, SEG BUG ❌段地址 其他寄存器：SI 字、DI 字、ESI 双字 A DW B ; A，B为变量，则A的初始值为B的偏移地址（应该把变量A、B理解为地址） 双操作数指令，对两操作数的要求：不能同时是地址，同时因为变量算是地址，不能同时是变量。不允许出现不带方括号的寄存器符号。 移位指令 SHL AX, CL 如果想把变量A的值赋给变量B，mov AX [A], mov [B] AX。注意把寄存器的值赋给变量时的[B]。据说MOV B AX的写法是语法错误的，不太懂。 SEG&amp;OFFSET 如果 BUF 是一个变量或标签，它会被解析为一个内存地址。 CS寄存器用来存储当前执行代码段的基地址 DS（Data Segment）: 数据段寄存器，用于指向程序中使用的数据的段的基地址。 ES（Extra Segment）: 附加段寄存器，通常用于指向额外的数据段的基地址，供字符串和其他数据操作使用。 SS（Stack Segment）: 堆栈段寄存器，用于指向程序堆栈的段的基地址。"
  },"/pages/database/": {
    "title": "华中科技大学考研复试 数据库笔记",
    "keywords": "Jekyll",
    "url": "/pages/database/",
    "body": "第一章 数据库概述 DB（数据库）、DBMS（数据库管理系统）、DBS（数据库系统）三者之间的关系：DBS包括DB和DBMS。 数据库系统（DBS）是由数据库（DB）、数据库管理系统（DBMS）、应用程序和数据库管理员（Database Administrator，DBA）组成。 概念词：实体entitiy，联系（一对一/一对多/多对多，两个实体之间联系/实体自己的联系/多个实体联系），关系（就是一张表），元组，属性，码key（唯一标识，不含多余属性），数据模型，二级映像与数据的独立性 候选码 candidate key：主属性组，可以唯一地标识一个元组 主码 primary key：从多个候选码中选出一个座位主码 主属性：候选码的属性称为主属性；非主属性：不包含在任何候选码中的属性 B+索引属于内模式，关系（数据表）、触发器属于模式，视图属于外模式/子模式。 关系代数的五个基本操作：投影（去重），选择，并，差，笛卡尔积。关系代数中的除法R ÷ S用于找出R中所有与S中所有元组都有关系的元组。 数据独立性（体现的是应用程序与使用数据的独立，总之当数据库如何改变，不影响应用程序，应用程序不变）分类： 逻辑（数据）独立性——改变模式，或改变模式/子模式映像，内模式不变，应用程序不变 物理（数据）独立性——改变内模式，应用程序不变 unique（唯一可为NULL） 自然连接 ⋈，左外连接（就是把左边关系R中要舍弃的元组保留） 聚集索引 完整性约束： 实体完整性：主属性不能去空值 参照完整性：确保表中的外键值必须在另一个表的主键中存在，或者是NULL（如果允许的话） 用户自定义完整性：UNIQUE、NOT NULL、CHECK 数据库范式： 1NF：一个正确的数据表就满足1NF。反例：一个列包含子列，就不是1NF。 2NF：每一个非主属性完全依赖于码。例如：AB是码，但是有B-&gt;C，则关系不满足2NF。 3NF：不存在非主属性对码的传递依赖。 BCNF： 4NF： 求闭包 求最小函数依赖集（最小覆盖）过程/极小化过程： 对于所有形如A-&gt;BC拆分成A-&gt;B, A-&gt;C 对于所有形如DE-&gt;F查看是否有D-&gt;E（或者E-&gt;D），有则去掉DE-&gt;F中多余的E（或者D） 对于所有依赖（例如X-&gt;Y），假设将其去掉，看剩余的函数依赖是否可以由X决定Y，如果可以则将X-&gt;Y去掉。 🔴 模式分解： 1. 具有无损连接性的模式分解：R与分解后R1…Rn自然连接的结果相等 1. 保持函数依赖的模式分解 数据库设计各阶段的典型步骤：画ER图（概念结构设计），数据库外模式（逻辑结构设计），生成DBMS系统支持的数据模型（逻辑结构设计），建立索引（物理结构设计） 聚簇索引和非聚簇索引： 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据。非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。 一个基本表最多只能建立一个聚簇索引。经常更新的列不宜建立聚簇索引。 连接操作的实现： 排序合并法 嵌套循环法 索引连接/Hash连接 数据库设计相关概念 数据抽象（分类 ismember of，聚集is part of，概括is subset of） 🟠冲突的种类：属性冲突、命名冲突、结构冲突==每种的例子== 🟠数据冗余，消除冗余的方法 锁的复习：① 锁的种类（S、X、意向锁，粒度树，🔴相容矩阵 ） 相容矩阵：IS和IS, S, IX, SIX相容，IX和IX相容，S和S相容 自主存取控制DAC（C2），强存取控制MAC（B1）。 SQL查询练习 除法，涉及到相关嵌套子查询 教学数据库有3个关系： 学生信息关系 student(sno，sname，age，sex) 学生选课关系 sc(sno，cno，score) 学校课程关系 course(cno，cname) (1) 检索所学课程包含了C002课程的学生学号 思路: 查找所有选择了C002课程的学生学号。这个问题相对简单，可以直接通过查询选课关系sc表，筛选出cno为C002的记录即可。 SELECT DISTINCT sno FROM sc WHERE cno = 'C002'; (2) 求至少选择了C001和C003两门课程的学生学号 方法一（使用NOT EXISTS）: 在sc表中排除那些没有选C001或C003的学生。 方法二（使用自连接）: 对选课表sc自连接，条件为学号相同，一次筛选cno为C001，一次为C003，然后选出同时满足两个条件的学生学号。 SELECT DISTINCT sno FROM sc A WHERE NOT EXISTS ( SELECT * FROM course B WHERE cno IN ('C001', 'C003') AND NOT EXISTS ( SELECT * FROM sc C WHERE A.sno = C.sno AND B.cno = C.cno ) ); 外层查询(SELECT DISTINCT sno FROM sc A): 选择所有学生的学号，目的是从这个全集中筛选符合条件的学生。 第一个NOT EXISTS: 对于每个学生（由外层查询的A.sno指定），我们检查是否存在他们没有选的课程C001或C003。 第二个NOT EXISTS: 对于每门课（由上一层的B.cno指定），我们检查是否存在没有这门课的记录。 SELECT * FROM sc C WHERE A.sno = C.sno AND B.cno = C.cno: 确定学生A是否选了课程B。如果这个查询找不到记录（意味着学生A没选课程B），那么第二个NOT EXISTS的条件成立，表明学生A至少缺少一门必选的课程，因此他们不应该被包括在结果中。 SELECT s1.sno FROM (SELECT * FROM sc WHERE cno = 'C001') AS s1 JOIN (SELECT * FROM sc WHERE cno = 'C003') AS s2 ON s1.sno = s2.sno; FROM (SELECT * FROM sc WHERE cno = ‘C001’) AS s1: 创建一个临时表s1，包含所有选了C001的记录。 JOIN (SELECT * FROM sc WHERE cno = ‘C003’) AS s2: 将s1与另一个临时表s2进行连接，s2包含所有选了C003的记录。 ON s1.sno = s2.sno: 连接条件是两个临时表中的学生编号（sno）相同。这样的连接确保了我们只会得到同时选了这两门课的学生。 (3) 求至少学习了学生S003所学课程的学生学号 思路: 先找出S003学生所选的所有课程，然后找出所有选了这些课程的其他学生，确保这些学生至少选了S003学生所选的所有课程。 SELECT DISTINCT A.sno FROM sc AS A WHERE NOT EXISTS ( SELECT * FROM sc AS B WHERE B.sno = 'S003' AND NOT EXISTS ( SELECT * FROM sc AS C WHERE A.sno = C.sno AND B.cno = C.cno ) ); 外层查询: 选择所有学生的学号（sno），确保学号是唯一的。 第一层嵌套NOT EXISTS: 对于每个学生，检查是否存在S003所选的课程，这些课程没有被当前考虑的学生选过。 第二层嵌套NOT EXISTS: 对于S003选过的每门课程，检查当前考虑的学生是否也选了这门课。 (4) 求选择了全部课程的学生的学号 思路: 对于每门课程，检查是否所有学生都至少选了这门课程。这可以通过双重NOT EXISTS实现：对于每门课（外层NOT EXISTS），找不到一个学生（内层NOT EXISTS）没有选这门课。 SELECT DISTINCT A.sno FROM sc AS A WHERE NOT EXISTS ( SELECT * FROM course AS B WHERE NOT EXISTS ( SELECT * FROM sc AS C WHERE A.sno = C.sno AND B.cno = C.cno ) ); 外层查询: 选出所有学生的学号。 第一层嵌套NOT EXISTS: 检查是否存在课程，这门课程没有被当前考虑的学生选过。 第二层嵌套NOT EXISTS: 对于每门课程，确认当前学生是否选了这门课。 (5) 求选择了全部课程的学生的学号和姓名 思路: 类似于上一题，但需要在学生信息表student和选课关系表sc之间进行连接操作，以获取满足条件的学生的学号和姓名。 SELECT DISTINCT A.sno, S.sname FROM student AS S JOIN sc AS A ON S.sno = A.sno WHERE NOT EXISTS ( SELECT * FROM course AS B WHERE NOT EXISTS ( SELECT * FROM sc AS C WHERE A.sno = C.sno AND B.cno = C.cno ) ); JOIN操作: 首先，通过JOIN操作连接student表和sc表，这样我们可以同时获取学生的学号和姓名。 外层查询: 选择所有学生的学号和姓名。 第一层嵌套NOT EXISTS: 检查是否存在课程，这门课程没有被当前考虑的学生选过。 第二层嵌套NOT EXISTS: 确认当前学生是否选了每门课。"
  },"/pages/feng_and_me/": {
    "title": "我的本科四年和峰哥的爱恨情仇",
    "keywords": "",
    "url": "/pages/feng_and_me/",
    "body": ""
  },"/pages/SQL_summary/": {
    "title": "数据库SQL语句用法总结",
    "keywords": "Jekyll",
    "url": "/pages/SQL_summary/",
    "body": "表 索引 元组的增删改查 视图 权限 触发器 🔵 练习题 查询等练习 一、 学生Student（sno,sname,sbirthday, ssex） 课程Course（cno,cname,teacher） 选修SC（sno,cno,score） 请用一条Sql语句完成查询： 🔵 查询存在两名及以上不及格成绩的课程名、最低成绩、最高成绩和平均成绩。 Select course.cname, Min(sc.score), Max(sc.score), Avg(sc.score) From course,sc Where course.cno = sc.cno Where sc.cno in ( select cno from sc where score &lt; 60 group by cno having count(*) &gt; 1 ) Group By course.cname 🔵 若“操作系统”成绩不为空，则更新每个同学的“数据库”课程成绩为“操作系统”课程成绩。 # 题干中给出的是课程的cname，需要使用到course表。先简化问题： # 假设操作系统课程的cno是OS，数据库课程的cno是DB Update sc Set score = ( Select score From sc sc1 Where sc1.sno = sc.sno And sc1.cno = 'OS' ) # sc查询每一条元组，通过子查询获取该元组OS课程成绩 Where cno = 'DB' # 更新的是数据库课程成绩 And Exists ( # 子查询确保OS成绩非空 Select * From sc sc2 Where sc2.sno = sc.sno And cno = 'OS' And sc2.score is not null ) # 参考答案： Update sc Set score = (Select score From sc sc1 Where sc1.sno=sc.sno And sc1.cno in (Select cno From course Where cname =’操作系统’)) Where cno in (Select cno From course Where cname =’数据库’) And Exists (Select * From sc sc2 Where sc2.sno = sc.sno And sc2.score is not null And cno in (Select cno From course Where cname =’操作系统’)) 授权练习 关系模式如下： 职工（职工号，姓名，年龄，职务，工资，部门号） 部门（部门号，名称，经理名，地址，电话号） 请用SQL的GRANT 和REVOKE语句（加上视图机制）完成以下授权定义或存取控制功能。 用户王明对两个表有SELECT 权力。 GRANT SELECT ON 职工,部门 TO 王明 每个职工只对自己的记录有SELECT 权力。 CREATE VIEW 张三记录 AS SELECT * FROM 职工 WHERE 职工.姓名=‘张三’ GRANT SELECT ON 张三记录 TO 张三 GRANT SELECT ON 职工 WHEN USER()=NAME TO ALL;"
  },"/2024-03-21-coding_quick_review.html": {
    "title": "代码快速复习",
    "keywords": "",
    "url": "/2024-03-21-coding_quick_review.html",
    "body": "#include &lt;stdio.h&gt; int main() { printf(\"Hello world!\\n\"); return 0; } C语言（C++）复习 输入输出 字符串处理 文件IO C++ STL与库函数 牛客网练习题链接 练习题目 判断是否为闰年 判断是否为质数 IsPrime 输出int整数的32位二进制 表达式求值 将数值去掉n位后返回最小的那个数 🔴 图的算法 🔴 动态规划（回文子串）的一些内容的复习 🔴 分数转换成小数 C语言（C++）复习 如果可以使用C++，主要注意下面C语言用法： C语言可以格式化输入scanf(\"%d.%d.%d.%d\", &amp;a, &amp;b, &amp;c, &amp;d); C语言可以格式化输出printf(\"%03d\\n\", 7); 多次获取值（适用于从文件读入） 输入输出 // 输入 scanf(\"%d\", &amp;a); scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); scanf(\"%d.%d.%d.%d\", &amp;a, &amp;b, &amp;c, &amp;d); // 例如输入 192.108.12.1,则abcd会输入为相应值 scanf(\"%s\", str); // char str[50]; （没有地址符号） gets(str); // 输入一行字符串 getline(cin, str); // 输入一行字符串 string str; 注：使用getline获取一行的数据时，如果之前有输入过字符，会在缓冲区中留下回车符号。此时必须使用getchar()把缓冲区中的回车去掉。 #include &lt;iostream&gt; using namespace std; int main(int argc, char *argv[]) { string ss, sstest; cin &gt;&gt; ss; getchar(); // 要把缓冲区中的回车去掉，没有这行代码sstest为空 getline(cin, sstest); cout &lt;&lt; \"sstest: \" &lt;&lt; sstest &lt;&lt; endl; cout &lt;&lt; \"sstest's length: \" &lt;&lt; sstest.length() &lt;&lt; endl; } // 输出 printf(\"%d\\n\", 127); // 127 printf(\"%03d\\n\", 7); // 007 printf(\"%f\\n\", 314.15); // 314.159000 （float类型） printf(\"%.2f\\n\", 314.15); // 314.15 指定精度 printf(\"%lf\\n\", 314.15); // 314.159000 （double类型） printf(\"%c\\n\", 'c'); // c printf(\"%s\\n\", str); // char str[50] （没有地址符号） printf(\"%o\\n\", 177); // 177 八进制 printf(\"%x\\n\", 177); // b1 十六进制 printf(\"%e\\n\", 314.15); // 3.141590e+02 Online Judge中连续多组测试数据的输入： while (scanf(\"%d\", &amp;num) != EOF) { //... } while (gets(str)) { // 输入一行字符串 //... } while (cin &gt;&gt; a &gt;&gt; b) { //... } while (getline(cin, str)) { //... } 字符串处理 char str[50]; scanf(\"%s\", str); printf(\"%s\\n\", str); // 下面的函数在&lt;string.h&gt;头文件中 printf(\"%d\\n\", strlen(str)); char str2[50]; strcpy(str2, str1); // 把str1复制到str2中 文件IO （IO感觉真的不太常用），这里只介绍通过fgetc(FILE*)一个一个字符读取文件，通过fputc(char, FILE*)一个一个字符写入文件。 void fileRead() { FILE* fp = fopen(\"文件路径\", \"r\"); //以读(r)的方式打开文件 char ch; while((ch = fgetc(fp)) != EOF) { // 一个一个字符串读入 // ... } fclose(fp); } char *fgets(char *str, int n, FILE *stream); // str：指向一个字符数组的指针，用于存储读取到的字符串。 // n：指明最多读取多少个字符，包括最后的空字符。为了安全读取整行，这个值应该是str指向的数组的大小。 // stream：指定从哪个文件流读取数据，通常是一个FILE *类型的文件指针。 void fileWrite() { File* fp = fopen(\"文件路径\", \"w\"); // 以写(w)的方式打开文件，文件不存在会自动创建，文件存在会覆盖掉之前的内容 string ss = \"Input content...\"; for (char c: ss) fputc(c, fp); fclose(fp); } C++ STL与库函数 stio()和to_string() // stack stack&lt;int&gt; num; num.push(9); // top()返回栈顶元素，pop()删除栈顶元素不返回值 int tmp1 = num.top(); num.pop(); // map map&lt;char,char&gt; rev = { {')', '('},{']','['},{'}','{'} }; // map可以使用这种方式初始化 // 用stack&lt;pair&lt;int, int&gt;&gt;保存图的邻接链表 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;pair&lt;int, int&gt;&gt; edge = { {1,2}, {3,4}, {5,6} }; edge.push_back({12, 34}); for (int i = 0; i &lt; edge.size(); i++) cout &lt;&lt; edge[i].first &lt;&lt; \" \" &lt;&lt; edge[i].second &lt;&lt; endl; } 牛客网练习题链接 牛客网华中科技大学历年计算机考研复试上机题在线练习链接点这里。 【PS】华中科技大学复试的机试环节，是将每道题目写好的代码放入指定的文件夹中保存在PC上，并非像LeetCode/牛客那样的线上测试评分。所以包括牛客网的题目，有些题目的测试数据也是不严谨的。 练习题目 判断是否为闰年 (year % 400 == 0) || (year % 100!=0 &amp;&amp; year % 4==0) 判断是否为质数 IsPrime 输出int整数的32位二进制 表达式求值 #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;map&gt; using namespace std; int val[6]; stack&lt;int&gt; num; stack&lt;char&gt; op; map&lt;char,char&gt; rev = { {')', '('},{']','['},{'}','{'} }; // map可以使用这种方式初始化 // priority int pri(char c) { if (c == '+' || c == '-') return 1; if (c == '*' || c == '/' || c =='%') return 2; if (c == '^') return 3; return -1; } int isOp(char c) { return c == '+' || c == '-' ||c == '*' || c == '/' || c =='%'||c == '^'; } int mi(int num1, int num2) { int tmp = num1; for (int i = 0; i &lt; num2 - 1; i++) num1 *= tmp; return num1; } void cal() { int tmp2 = num.top(); num.pop(); int tmp1 = num.top(); num.pop(); char c = op.top(); op.pop(); if (c == '+') num.push(tmp1 + tmp2); else if (c == '-') num.push(tmp1 - tmp2); else if (c == '*') num.push(tmp1 * tmp2); else if (c == '/') num.push(tmp1 / tmp2); else if (c == '%') num.push(tmp1 % tmp2); else if (c == '^') num.push(mi(tmp1, tmp2)); } int main() { string ss; cin &gt;&gt; ss; for (int i = 0; i &lt; 6; i++) cin &gt;&gt; val[i]; //输入a~f for (char c : ss) { if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') { // 表示num num.push(val[c-'a']); } else if (c == '(' || c == '[' || c == '{') { op.push(c); } else if (isOp(c)) { // TODO !这里一定不要忘记先判断一下栈是否为空！！ while (!op.empty() &amp;&amp; pri(op.top()) &gt;= pri(c)) cal(); op.push(c); } else { while (rev[c] != op.top()) cal(); op.pop(); } } while (!op.empty()) cal(); cout &lt;&lt; num.top(); } 将数值去掉n位后返回最小的那个数 #include &lt;iostream&gt; using namespace std; // 取出num第index位数字后返回 string remove(int num, int index) { string ss = to_string(num); string res; for (int i = 0; i &lt; index; i++) res.push_back(ss[i]); for (int i = index+1; i &lt; ss.length(); i++) res.push_back(ss[i]); return res; } // a：输入的数，n：要删除的数字的数量 int process(int a, int n) { if (n == 0) return a; string ss = to_string(a); int res = 0x3f3f3f3f; for (int i = 0; i &lt; ss.length(); i++) { string cur = remove(a, i); int tmp = process(stoi(cur), n-1); res = min(res, tmp); } return res; } int main() { cout &lt;&lt; process(692434354, 5); } 🔴 图的算法 单源最短路（Dijkstra） int vis[n]; int dist[n]; int path[n]; vector&lt;pair&lt;int, int&gt;&gt; edge; void dijkstra(int v) { // 初始化 for (int i = 0; i &lt; n; i++) { vis[i] = 0; dist[i] = MAX; path[i] = -1; } dist[v] = 0; for (int j = 0; j &lt; n; j++) { int u = 0; int minDist = MAX; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; minDist &gt; dist[i]) { u = i; minDist = dist[i]; } } vis[u] = 1; for (int i = 0; i &lt; edge[u].size(); i++) { int v = edge[u][i].first, cost = edge[u][i].second; if (dist[v] &gt; dist[u] + cost) { dist[v] = dist[u] + cost; path[v] = u; } } } } 最小生成树 void Prim() { int i, j, k, u; int ldist; // 存储最小代价 struct EdgeNode* p; // 初始化 for (i = 1; i &lt;= n; i++) { lowcost[i] = INF; mark[i] = 0; // 初始时，MST中没有顶点 vex[i] = -1; } // 从顶点1开始构造MST mark[1] = 1; lowcost[1] = 0; for (p = Head[1]; p != NULL; p = p-&gt;link) { k = p-&gt;VerAdj; lowcost[k] = p-&gt;cost; vex[k] = 1; } // 构造MST的主循环 for (j = 1; j &lt; n; j++) { ldist = INF; // 重置最小代价 u = -1; // 即将被访问的顶点 // 确定即将被访问的顶点u for (i = 1; i &lt;= n; i++) { if (!mark[i] &amp;&amp; lowcost[i] &lt; ldist) { ldist = lowcost[i]; u = i; } } // 将顶点u加入MST if (u != -1) { // 找到了有效的顶点 mark[u] = 1; // 更新与u相邻顶点到MST的最小代价 for (p = Head[u]; p != NULL; p = p-&gt;link) { k = p-&gt;VerAdj; if (!mark[k] &amp;&amp; p-&gt;cost &lt; lowcost[k]) { lowcost[k] = p-&gt;cost; vex[k] = u; } } } } } 并查集 拓扑排序 🔴 动态规划（回文子串）的一些内容的复习 🔴 分数转换成小数 string fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { // 分子为0，直接返回\"0\" return \"0\"; } string result; // 如果结果为负数（异号），在结果前加上负号 if (numerator &lt; 0 ^ denominator &lt; 0) result += '-'; // 使用long long类型避免溢出，并取绝对值 long long a = llabs(numerator), b = llabs(denominator); // 计算整数部分，并将余数乘10准备计算小数部分 result += to_string(a / b); long long remainder = a % b; if (remainder == 0) { // 如果能整除，直接返回整数部分 return result; } // 处理小数部分 result += '.'; unordered_map&lt;long long, int&gt; map; // 用于记录余数出现的位置 // 当余数不为0且该余数未出现过时，继续进行循环 while (remainder != 0 &amp;&amp; map.find(remainder) == map.end()) { map[remainder] = result.size(); // 记录当前余数的位置 remainder *= 10; // 余数乘10准备下一轮计算 result += to_string(remainder / b); // 计算新的一位小数 remainder %= b; // 更新余数 } if (remainder != 0) { // 如果余数非0，说明发现了循环小数 // 在循环开始的位置插入左括号，并在字符串末尾加上右括号 result.insert(map[remainder], \"(\"); result += ')'; } return result; }"
  },"/2024-03-18-chatgpt.html": {
    "title": "ChatGPT 提问汇总",
    "keywords": "",
    "url": "/2024-03-18-chatgpt.html",
    "body": "表达式求值（处理负数情况） 你提到的代码在处理含有括号和负数的表达式时确实存在问题，特别是在处理类似2*(-3)这样的表达式时，它不能正确地处理负数。原因在于它没有专门处理一元运算符（如负号）的逻辑，使得程序在尝试将-3作为一个整体解析时出现错误。此外，代码中没有直接处理空格，可能会影响表达式的正确解析。 为了修复这个问题，我们需要增加一些逻辑来处理一元运算符，尤其是在遇到(后面紧跟着的-号时，我们可以将其视为一元运算符，并且在解析到一元运算符时，应当正确地将其应用到紧随其后的数字上。一种方法是在解析到这种情况时，将负号和紧随其后的数字一起作为一个负数处理。 下面是修改后的代码，包括对处理一元运算符的支持： #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; bool isOp(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^'; } bool isDigit(char c) { return isdigit(c) || c == '.'; } double cal(double a, double b, char op) { switch (op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; case '%': return fmod(a, b); case '^': return pow(a, b); default: return 0; } } string inToPost(const string&amp; infix) { string post; stack&lt;char&gt; op; map&lt;char, int&gt; pri = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'%', 2}, {'^', 3} }; map&lt;char, char&gt; rev = { {')', '('}, {']', '['}, {'}', '{'} `}; // 处理负号的方法 auto handleNegative = [&amp;op, &amp;post](bool isUnaryMinus) { if (isUnaryMinus) { // 如果是一元运算符（负号） post += \"0 \"; // 向后缀表达式中添加0，以便用0减去后面的数 } op.push('-'); // 将减号作为二元运算符处理 }; bool prevIsOp = true; // 前一个字符是否是运算符或左括号，用于识别一元运算符 for (int i = 0; i &lt; infix.size(); ++i) { char c = infix[i]; if (c == ' ') continue; // 忽略空格 if (isDigit(c)) { prevIsOp = false; while (i &lt; infix.size() &amp;&amp; (isDigit(infix[i]) || infix[i] == '.')) { post += infix[i++]; } post += ' '; --i; } else if (c == '(' || c == '[' || c == '{') { prevIsOp = true; op.push(c); } else if (isOp(c)) { if (c == '-' &amp;&amp; prevIsOp) { // 处理一元负号 handleNegative(true); } else { while (!op.empty() &amp;&amp; pri[op.top()] &gt;= pri[c]) { post += op.top(); post += ' '; op.pop(); } op.push(c); prevIsOp = true; } } else if (c == ')' || c == ']' || c == '}') { while (!op.empty() &amp;&amp; op.top() != rev[c]) { post += op.top(); post += ' '; op.pop(); } op.pop(); // Pop the opening bracket prevIsOp = false; } } while (!op.empty()) { post += op.top(); post += ' '; op.pop(); } return post; } double evaluatePostfix(const string&amp; postfix) { stack&lt;double&gt; values; string num; for (char c : postfix 用更简单的C++语法对关键的处理逻辑进行修改。我们将重点修改inToPost函数，以处理一元负号的情况，同时尽量减少对现代C++特性的使用。这里，我们将简化处理，具体地，在遇到一个负号时，需要判断它是作为一元运算符（即负号）还是二元运算符（减号）。 为了处理这个问题，我们可以引入一个额外的标志变量，用来标记当前是否可能遇到一元运算符。具体来说，如果负号出现在表达式的开始位置或者一个左括号之后，我们可以认为它是一元运算符。 string inToPost(const string&amp; infix) { string post; stack&lt;char&gt; opStack; map&lt;char, int&gt; precedence = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'%', 2}, {'^', 3} }; bool mayBeUnary = true; // 初始时可能遇到一元运算符 for (char c : infix) { if (isDigit(c)) { post += c; mayBeUnary = false; // 数字之后不可能是一元运算符 } else if (c == ' ') { // 忽略空格 } else if (isOp(c)) { if (c == '-' &amp;&amp; mayBeUnary) { // 处理一元负号 post += \"0 \"; // 表达式前添加0 } while (!opStack.empty() &amp;&amp; precedence[opStack.top()] &gt;= precedence[c]) { post += ' '; post += opStack.top(); opStack.pop(); } post += ' '; opStack.push(c); mayBeUnary = true; // 运算符后可能遇到一元运算符 } else if (c == '(') { opStack.push(c); mayBeUnary = true; // 左括号后可能遇到一元运算符 } else if (c == ')') { while (!opStack.empty() &amp;&amp; opStack.top() != '(') { post += ' '; post += opStack.top(); opStack.pop(); } if (!opStack.empty()) opStack.pop(); // 弹出左括号 mayBeUnary = false; // 右括号后不可能是一元运算符 } } while (!opStack.empty()) { post += ' '; post += opStack.top(); opStack.pop(); } return post; } 高精度除法模拟 高精度除法模拟通常指的是在处理超出标准数据类型（如int，long long等）范围的大数进行除法运算时，通过模拟手工除法的过程来实现。这种方法通常涉及到字符串处理或者数组来表示大数，逐位或逐段地进行计算。下面提供一个简化的高精度除法（大数除以小数）的实现示例，使用C++编写。这个例子中，大数使用字符串表示，被除数可以是一个较大的数，而除数是一个int范围内的数。 cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; // 高精度除法：大数（字符串表示）除以小数（int表示），返回商（字符串表示） string highPrecisionDivision(string dividend, int divisor) { string result; // 存储结果 int index = 0; // 处理到dividend的哪一位 int temp = dividend[index] - '0'; // 当前处理的数 while (temp &lt; divisor) { temp = temp * 10 + (dividend[++index] - '0'); } while (dividend.size() &gt; index) { result += (temp / divisor) + '0'; // 计算当前位的结果，并转换为字符 temp = (temp % divisor) * 10 + dividend[++index] - '0'; } // 移除结果前面的0 while (result[0] == '0' &amp;&amp; result.length() != 1) { result.erase(0, 1); } return result.length() == 0 ? \"0\" : result; } int main() { string dividend; int divisor; cout &lt;&lt; \"Enter the dividend (big number): \"; cin &gt;&gt; dividend; cout &lt;&lt; \"Enter the divisor (small number): \"; cin &gt;&gt; divisor; string quotient = highPrecisionDivision(dividend, divisor); cout &lt;&lt; \"Quotient: \" &lt;&lt; quotient &lt;&lt; endl; return 0; } 这段代码实现了大数（使用字符串表示）除以小数（使用int表示）的功能。它通过模拟手工除法的方式，从左到右逐位处理被除数，计算每一步的商，并将结果累加到结果字符串中。需要注意的是，这个实现假设除数是一个正整数，且没有处理除法的余数部分。如果需要处理更复杂的情况（如负数，或者需要余数等），则需要对代码进行相应的扩展。 账户合并 class Solution { public: int find(int v, vector&lt;int&gt;&amp; fa) { if (v == fa[v]) return v; else return fa[v] = find(fa[v], fa); } void merge(int u, int v, vector&lt;int&gt;&amp; fa) { int fu = find(u, fa); int fv = find(v, fa); if (fu != fv) fa[fv] = fu; } vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) { map&lt;string, string&gt; emailToName; map&lt;string, int&gt; emailToId; int count = 0; // 用于给每个邮箱分配一个唯一的ID for (auto&amp; account : accounts) { string&amp; name = account[0]; for (int i = 1; i &lt; account.size(); i++) { if (!emailToId.count(account[i])) { emailToId[account[i]] = count++; emailToName[account[i]] = name; } } } vector&lt;int&gt; fa(count); for (int i = 0; i &lt; count; i++) fa[i] = i; for (auto&amp; account : accounts) { int firstId = emailToId[account[1]]; for (int i = 2; i &lt; account.size(); i++) { merge(firstId, emailToId[account[i]], fa); } } // 使用map来归类和排序同一用户的所有邮箱 map&lt;int, vector&lt;string&gt;&gt; ans; for (auto&amp; email : emailToId) { int root = find(email.second, fa); ans[root].push_back(email.first); } // 构建最终答案 vector&lt;vector&lt;string&gt;&gt; mergedAccounts; for (auto&amp; p : ans) { vector&lt;string&gt; account; account.push_back(emailToName[p.second[0]]); // 添加用户名 sort(p.second.begin(), p.second.end()); for (auto&amp; email : p.second) { account.push_back(email); // 添加邮箱 } mergedAccounts.push_back(account); } return mergedAccounts; } }; 最长公共子串（Longest Common Substring） cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 查找最长公共子串 string longestCommonSubstring(const string&amp; s1, const string&amp; s2) { int m = s1.length(), n = s2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); int maxLength = 0, endPos = 0; // maxLength记录最长公共子串的长度，endPos记录结束位置 for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (s1[i - 1] == s2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &gt; maxLength) { maxLength = dp[i][j]; endPos = i - 1; // 更新最长公共子串的结束位置 } } } } return s1.substr(endPos - maxLength + 1, maxLength); } int main() { string s1 = \"abcde\"; string s2 = \"babc\"; cout &lt;&lt; \"Longest Common Substring: \" &lt;&lt; longestCommonSubstring(s1, s2) &lt;&lt; endl; return 0; } 最长回文子串（Longest Palindromic Substring） cppCopy code #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 查找最长回文子串 string longestPalindromicSubstring(const string&amp; s) { int n = s.length(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); int start = 0, maxLength = 1; // start记录最长回文子串的起始位置，maxLength记录长度 for (int i = 0; i &lt; n; ++i) { dp[i][i] = true; // 单个字符是回文 } for (int i = 0; i &lt; n - 1; ++i) { if (s[i] == s[i + 1]) { dp[i][i + 1] = true; // 相邻字符相同是回文 start = i; maxLength = 2; } } for (int len = 3; len &lt;= n; ++len) { // len是当前检查的子串长度 for (int i = 0; i &lt;= n - len; ++i) { int j = i + len - 1; // 子串结束位置 if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) { dp[i][j] = true; start = i; maxLength = len; } } } return s.substr(start, maxLength); } int main() { string s = \"babad\"; cout &lt;&lt; \"Longest Palindromic Substring: \" &lt;&lt; longestPalindromicSubstring(s) &lt;&lt; endl; return 0; } 这两个动态规划的解法都是基于子问题的解来构建整体问题的解，从而达到降低时间复杂度的目的。最长公共子串问题的动态规划解法时间复杂度和空间复杂度都是O(m*n)，其中m和n分别是输入的两个字符串的长度。最长回文子串问题的动态规划解法时间复杂度也是O(n^2)，空间复杂度同样是O(n^2)，其中n是输入字符串的长度。 1. R ÷ S的等价关系代数表达式求解过程 假设我们有两个表R(A, B, C)和S(B, C, D)。我们要找的是R ÷ S的结果，即在R中找到所有与S中所有(B, C)组合都存在关系的A值。这个过程可以分解为以下步骤： 投影：首先，对R和S分别进行投影，去除不需要比较的属性。对于R，我们只关心(A, B, C)，所以保持不变；对于S，我们也只关心(B, C)，所以对S做投影π(B, C)(S)。 笛卡尔积和差集：接下来，我们需要找出R中存在而在S中没有的(B, C)组合。这可以通过将R与S的投影做笛卡尔积，然后从R中的(B, C)投影中减去这个结果得到。这个步骤实际上是在寻找R中有但S中没有的(B, C)组合，但这不是除法操作的直接结果，需要进一步的处理。 差集：为了得到最终结果，我们需要再次利用差集。这次，我们从R中所有可能的(A)中减去那些在步骤2中找到的与S中(B, C)不匹配的(A)。这样，剩下的就是在R中与S中所有(B, C)都存在关系的A值。 综上所述，一个较为接近的等价关系代数表达式可能是这样的： πA(R) - πA( ( πA,B,C(R) × πB,C(S) ) - R ) 但是，请注意，这个表达式并不完全精确对应于除法操作的标准定义，因为关系代数的除法操作是通过比较找出“完全匹配”的元组，而上述步骤更多的是一个概念上的解释，用于理解除法操作的效果。 2. 最长递增子序列的思路 最长递增子序列（Longest Increasing Subsequence, LIS）问题可以通过几种不同的方法解决，每种方法的时间复杂度略有不同。下面介绍两种常见的方法： 动态规划（DP） 动态规划是解决LIS问题的经典方法，时间复杂度为O(n^2)。 初始化一个长度等于原数组长度的dp数组，dp[i]存储以第i个元素结尾的最长递增子序列的长度。 遍历数组，对于每个元素nums[i]，再次遍历其之前的所有元素nums[j] (0 ≤ j &lt; i)。 如果nums[i] &gt; nums[j]，则nums[i]可以跟在nums[j]构成的递增子序列之后，此时更新dp[i] = max(dp[i], dp[j] + 1)。 最后，dp数组中的最大值即为整个数组的最长递增子序列的长度。 二分查找+贪心 这个方法的时间复杂度是O(n log n)，通过贪心策略加上二分查找来优化。 维护一个数组tails，其中tails[i]存储长度为i+1的所有递增子序列中末尾最小的元素。 遍历原数组，对于每个元素x，用二分查找在tails中找到第一个大于或等于x的元素，如果找到，更新它；如果没有找到，将x追加到tails末尾。 遍历结束时，tails的长度即为最长递增子序列的长度。 两种方法中，动态规划更容易理解和实现，适合大 汇编代码 写出把10号功能调用的IP和CS存储到自变量INTTEN_CS和INTTEN_IP的代码段 这里似乎是在谈论实模式下的汇编语言编程，特别是与中断有关的内容。10号功能调用听起来像是中断调用（比如，BIOS中断），但“存储到自变量INTTEN_CS和INTTEN_IP的代码段”具体要做的是在软件层面记录中断处理程序的CS（代码段寄存器）和IP（指令指针寄存器）值。 对于这个问题的解释，需要注意的是，在现代计算机架构中，直接操作IP和CS寄存器的情况很少，因为这涉及到操作系统级别的底层操作，通常是通过操作系统提供的API或者特定语言构造来实现。而且，直接操作这些寄存器通常是在汇编语言中进行的。在实模式下，可以通过软件中断调用来实现某些功能，但是直接获取中断向量的CS和IP值并存储它们，通常不是标准操作。 对于具体实现，如果是在DOS或类似环境下，一般会通过编写汇编程序来直接访问中断向量表（位于内存的低地址处）来获取某个中断处理程序的段地址（CS）和偏移地址（IP）。但这样的操作在现代操作系统中通常不被允许或需要特权。 在汇编语言中，要获取并存储某个中断号（如10号中断）的中断处理程序地址，通常需要访问中断向量表。中断向量表位于实模式内存的最低端，每个向量占用4个字节，前两个字节是偏移地址（IP），后两个字节是段地址（CS）。由于这是一个实模式的示例，我们将使用x86汇编语言，并假设使用的是DOS或类似环境。 下面是一个示例代码，用于获取10号中断（比如视频中断）的CS和IP值，并存储到INTTEN_CS和INTTEN_IP这两个字变量中： Copy code ; 假设 INTTEN_CS 和 INTTEN_IP 已经定义在数据段中 ; 假设数据段已经正确初始化 MOV AX, 0 ; 清零AX寄存器，用于后续操作 MOV ES, AX ; 将ES段寄存器设置为0，指向中断向量表的开始 MOV BX, 4*10 ; 计算10号中断向量的内存偏移量（每个向量4个字节） ; 获取10号中断的IP值（向量的前两个字节） MOV AX, [ES:BX] MOV INTTEN_IP, AX ; 获取10号中断的CS值（向量的后两个字节） MOV AX, [ES:BX+2] MOV INTTEN_CS, AX 请注意，实际使用时需要根据你的环境和具体要求调整代码，尤其是如何定义和使用INTTEN_CS和INTTEN_IP这两个变量。在现代操作系统中，直接操作硬件和中断向量表可能受到限制，该代码主要适用于DOS或其他实模式环境。 数组中出现次数不低于[n/2]的数 这个问题可以通过摩尔投票法解决，时间复杂度为O(n)，空间复杂度为O(1)。摩尔投票法是通过一系列的对抗消除，找出数组中出现次数超过一半的元素。 以下是用C++实现的代码： #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; int majorityElement(vector&lt;int&gt;&amp; nums) { int count = 0; int candidate = 0; for (int num : nums) { if (count == 0) { candidate = num; } count += (num == candidate) ? 1 : -1; } // 验证candidate是否确实是出现次数超过一半 count = 0; for (int num : nums) { if (num == candidate) count++; } if (count &gt; nums.size() / 2) return candidate; return -1; // 如果没有找到，则返回-1或者其他标识 } int main() { vector&lt;int&gt; nums = {2, 2, 1, 1, 1, 2, 2}; cout &lt;&lt; \"Majority Element: \" &lt;&lt; majorityElement(nums) &lt;&lt; endl; return 0; } R ÷ S的等价关系代数表达式 关系代数的除法运算R ÷ S用于找出R中所有与S中所有元组都有关系的元组。等价的关系代数表达式较为复杂，需要通过多步骤构建，主要思路是： 投影R和S关系中相关属性； 笛卡尔积操作，然后选择出符合条件的元组； 差集操作，找出只在R中出现而未完全与S匹配的元组； 再次投影以去除额外的属性，得到最终结果。 关系代数的除法R ÷ S用来找出能与S中所有元组匹配的R中的元组。一个直观的等价表达式涉及到差集和笛卡尔积操作。假设R(A, B)和S(B)，其中A和B表示属性列，我们要找的是所有在R中但不需要在S中出现的A值。 不过，直接写出等价的关系代数表达式相对复杂，需要结合具体的例子和上下文。一种简化的思路是首先对R按B做投影，然后从结果中减去（即差集）那些在与S做笛卡尔积后不能完全覆盖R的元组。但这个过程需要具体的步骤和实现，依赖于具体数据库和查询语言的功能，因此在此不易直接给出一个一般性的表达式。 理解除法操作最重要的是掌握其目的：找出与另一关系中所有元组都有关系的元组集合。具体实现通常需要结合其他操作，如投影、选择、差集等，来构造等价查询。"
  },"/2024-02-11-python.html": {
    "title": "项目笔记——Video Downloader&amp;Python语法学习",
    "keywords": "",
    "url": "/2024-02-11-python.html",
    "body": "python环境与配置 使用conda activate &lt;myenv&gt;更换terminal中的环境。 Python程序中，使用import sys，print(sys.executable)打印环境。 终端中使用which python查看python路径，python --version查看python版本。 import的路径 python语法 python类中函数的命名规范： 函数名一律小写，若有多个单词用下划线隔开；双下划线 __ 开头的方法或属性默认是私有的，只能在类的内部被访问 变量名最好小写，若有多个使用下划线分开；常量使用全大写，多个单词使用下划线隔开 。 from rich.console import Console：用于打印文本到控制台，可以添加样式和高亮显示 ` encode = “UTF-8-SIG” if system() == “Windows” else “UTF-8” `：”UTF-8-SIG” 在UTF-8基础上，文件的开头包含了一个特殊的字节顺序标记（BOM）。BOM用于一些Windows应用程序，帮助它们正确地解释UTF-8编码的文本。"
  },"/jekyll/2023-12-12-footnotes.html": {
    "title": "Using Footnotes",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-12-12-footnotes.html",
    "body": "This jekyll-theme supports MathJax to render footnotes in markdown. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents[^1]. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents1. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 Long contents long contents ….. a b c d Sub title 1 Sub title 2 Sub title 3 https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem &#8617;"
  },"/jekyll/2023-10-14-math-latex.html": {
    "title": "MathJax and LaTeX",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-10-14-math-latex.html",
    "body": "This jekyll-theme supports MathJax to render $\\LaTeX$ and mathematics expressions. TIP Currently, Kramdown uses double dollar sign delimiters for inline and display math: https://kramdown.gettalong.org/syntax.html#math-blocks. e.g., The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: $$ x^n + y^n = z^n $$ The well known Pythagorean theorem $x^2 + y^2 = z^2$ was proved to be invalid for other exponents. Meaning the next equation has no integer solutions: \\[x^n + y^n = z^n\\] Another example with more complex markups: When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are \\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\] Refer to the MathJax website for more examples."
  },"/jekyll/2023-08-31-mermaid.html": {
    "title": "Diagrams with mermaid.js",
    "keywords": "Jekyll",
    "url": "/jekyll/2023-08-31-mermaid.html",
    "body": "This jekyll-theme supports mermaid.js to render diagrams in markdown. To enable the mermaid support, you need to set mermaid: true in the front matter of your post. --- title: Diagrams with mermaid.js date: 2023-08-31 layout: post mermaid: true --- Then you can use mermaid syntax in your markdown: graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; Or, even some complex examples: sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! Refer to the mermaid.js website for more examples."
  },"/jekyll/2022-06-30-tips_warnings_dangers.html": {
    "title": "Tips, Warnings, and Dangers",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-30-tips_warnings_dangers.html",
    "body": "This jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website. You could have the following markdown attributes (supported by kramdown): Tips Using a {: .block-tip} attribute: &gt; ##### TIP &gt; &gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have &gt; this or a similar version after installation. {: .block-tip } TIP This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have this or a similar version after installation. Warnings Using a {: .block-warning} attribute: &gt; ##### WARNING &gt; &gt; Be sure that you're familiar with things like async/await and object destructuring &gt; before continuing, as we'll be making use of features like these. {: .block-warning } WARNING Be sure that you’re familiar with things like async/await and object destructuring before continuing, as we’ll be making use of features like these. Dangers Using a {: .block-danger} attribute: &gt; ##### DANGER &gt; &gt; You cannot delete an ephemeral message. {: .block-danger } DANGER You cannot delete an ephemeral message."
  },"/jekyll/2022-06-26-wide_tables.html": {
    "title": "Wide tables",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-26-wide_tables.html",
    "body": "A wide tables needs to be wrapped into a div with class table-wrapper to make sure it displayed as expected on mobile devices. For example, &lt;div class=\"table-wrapper\" markdown=\"block\"&gt; |title1|title2|title3|title4|title5|title6|title7|title8| |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| &lt;/div&gt; Will be rendered as title1 title2 title3 title4 title5 title6 title7 title8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8"
  },"/jekyll/2022-05-24-page_cover.html": {
    "title": "Page with cover image",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-05-24-page_cover.html",
    "body": "The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata: --- title: Page with cover image author: Tao He date: 2022-05-24 category: Jekyll layout: post + cover: /assets/jekyll-gitbook/dinosaur.gif ---"
  },"/research/02-transform.html": {
    "title": "Transformer的学习（2）",
    "keywords": "",
    "url": "/research/02-transform.html",
    "body": ""
  },"/research/01-transform.html": {
    "title": "Transformer的学习（1）",
    "keywords": "",
    "url": "/research/01-transform.html",
    "body": "李宏毅 Self-attention 李宏毅老师《机器学习》课程笔记-4.1 Self-attention1（写了很多东西，挺干货的。包括最重要的attention计算过程）。 Attention核心思想 Attention核心思想2：Attention的思想如同它的名字一样，就是“注意力”，在预测结果时把注意力放在不同的特征上。 举个例子。比如在预测“我妈今天做的这顿饭真好吃”的情感时，如果只预测正向还是负向，那真正影响结果的只有“真好吃”这三个字，前面说的“我妈今天做的这顿饭”基本没什么用，如果是直接对token embedding进行平均去求句子表示会引入不少噪声。所以引入attention机制，让我们可以根据任务目标赋予输入token不同的权重，理想情况下前半句的权重都在0.0及，后三个字则是“0.3, 0.3, 0.3”，在计算句子表示时就变成了： 最终表示 = 0.01x我+0.01x妈+0.01x今+0.01x天+0.01x做+0.01x的+0.01x这+0.01x顿+0.02x饭+0.3x真+0.3x好+0.3x吃 怎么用知道了，那核心就在于这个权重怎么计算。通常我们会将输入分为query(Q), key(K), value(V)三种： 先用Q和K计算权重$\\alpha$，会用softmax对权重归一化： $\\alpha = softmax(f(QK))$ 再用权重对结果加权： $out = \\Sigma \\alpha_i * V_i$ 上文中QK的具体运算f有多种方法，常见的有加性attention和乘性attention： $f(Q.K) = tanh(W_1Q + W_2K)$ $f(Q,K) = QK^T$ 再深入理解下去，这种机制其实做的是寻址（addressing），也就是模仿中央处理器与存储交互的方式将存储的内容读出来，可以看一下李宏毅老师的课程。 Transformer模型原理 https://zhuanlan.zhihu.com/p/521380855 &#8617; https://zhuanlan.zhihu.com/p/43493999 这篇文章后面还介绍了attention在NLP中最早的应用：Seq2seq+attention。 &#8617;"
  },"/week/2024-03-17-week-algorithm-1.html": {
    "title": "数据结构&amp;算法（1）",
    "keywords": "",
    "url": "/week/2024-03-17-week-algorithm-1.html",
    "body": "1-1 螺旋矩阵 II（LeetCode） 1-2 最长公共子序列，最长回文子序列；最长公共子串，最长回文子串 最长公共子序列 分析 代码（java） 最长回文子序列 分析 代码（java） 1-3 表达式求值 分析 代码（c++） 1-4 高精度运算模拟 1-1 螺旋矩阵 II（LeetCode） 螺旋矩阵 II（LeetCode）：给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 【代码】 // 这道题在while循环中模拟时可以使用一个变量i+t/b/l/r的方式确认num二维的坐标值，稍微优化一下我的代码 #include &lt;iostream&gt; using namespace std; int N; int num[100][100]; int main() { cin &gt;&gt; N; int k = 1, t = 0, l = 0, r = N - 1, b = N - 1; int i = 0, j = 0; while (k &lt;= N * N) { for (i = t, j = l; j &lt;= r; j++) num[i][j] = k++; t++; for (i = t, j = r; i &lt;= b; i++) num[i][j] = k++; r--; for (i = b, j = r; j &gt;= l; j--) num[i][j] = k++; b--; for (i = b, j = l; i &gt;= t; i--) num[i][j] = k++; l++; } for (i = 0; i &lt; N; i++) { for (j = 0; j &lt; N; j++) cout &lt;&lt; num[i][j] &lt;&lt; \" \"; cout &lt;&lt; \"\\n\"; } return 0; } 1-2 最长公共子序列，最长回文子序列；最长公共子串，最长回文子串 🔵 区分：子序列和子串子序列 Subsequences 可以不连续，子串 Substrings 必须连续 Palindrome 回文 这其实是4道经典的字符串相关题目。 最长公共子序列：此题为LeetCode原题，中文题目链接点这里，英文题目链接点这里。 最长回文子序列：此题目是LeetCode原题，中文题目链接点这里，英文题目链接点这里。 最长公共子序列 str1 “a12bc345def” str2 “mnp123qrs45z” 最长公共子序列——“12345” 最重要的还是要考虑清楚： 分析 process函数以及参数的含义。调用process(i,j)表示只考虑str1[0…i]和str2[0…j]的最长公共子序列。 递归（减小问题规模）的方法。如果str[i]和str[j]相同，考虑公共子序列一定算入（和之后的子串问题形成对比）。如果不同，则需在process(i,j-1)和process(i-1,j)中选取最大的。 将递归函数转化为dp二维数组。因为process(i,j)需要调用信息只有process(i-1, j-1)，process(i,j-1)和process(i-1,j)，其实就是dp数组的左侧、上侧和左上角。 dp[i][j]只会参考当前位置上一层和左侧一个格子的dp值，因此也可以考虑把dp数组由二维压缩成一维的。 代码（java） 【暴力递归】 static int longestCommonSubsequence1(String s1, String s2) {    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) return 0;    char[] str1 = s1.toCharArray();    char[] str2 = s2.toCharArray();    return process(str1, str2, str1.length - 1, str2.length - 1); } //只考虑str1[0...i]和str2[0...j]的最长公共子序列 static int process(char[] str1, char[]str2, int i,int j) {    if(i==0 &amp;&amp; j == 0)//都只剩一个字符        return str1[i] == str2[j] ? 1:0;    else if (i==0) {//str1剩一个字符        if (str1[i] == str2[j]) return 1;        else return process(str1,str2,i,j-1);   }    else if (j == 0) {//str2剩下一个字符        if (str1[i] == str2[j]) return 1;        else return process(str1,str2,i-1,j);   }    else {        //分三种情况考虑：        // 1.str1的i可以包含在子序列中，str2的j不包含在子序列中        int p1 = process(str1,str2,i,j-1);        // 2.str1的i不包含在子序列中，str2的j可以包含在子序列中        int p2 = process(str1,str2,i-1,j);        // 3.str1的i和str2的j都包含在子序列中，这种情况的条件是str1[i]和str2[j]相等        int p3 = str1[i] == str2[j] ? 1+process(str1,str2,i-1,j-1):0;        // 注意，str1的i和str2的j都不包含在子序列中的情况被包含在了p1和p2两种情况中了   return Math.max(p1,Math.max(p2,p3));   } } 【暴力递归（优化）】 PS：虽然看上去简单，但是理解起来也困难了。递归的作用是在接触新题时思考解决问题的思路。我觉得没有必要必须优化这么简洁。 //只考虑str1[0...i]和str2[0...j]的最长公共子序列 static int process(char[] str1,char[]str2,int i,int j) {    if (i &lt; 0 || j &lt; 0) return 0;//越界的情况，这样写避免了上面那样多种情况考虑    if (str1[i] == str2[j]) {//如果满足这个条件了，那么一定是这种情况的子序列长度最长，则没有必要计算下面的两种情况。        return 1+process(str1,str2,i-1,j-1);   }    int p1 = process(str1,str2,i,j-1);    int p2 = process(str1,str2,i-1,j);    return Math.max(p1,p2); } 【记忆化搜索】 // https://leetcode.com/problems/longest-common-subsequence/discuss/590781/From-Brute-Force-To-DP private Integer[][] dp;//注意这里用的是Integer的数组，方便查看是否被填过 public int longestCommonSubsequence(String text1, String text2) {    dp = new Integer[text1.length()][text2.length()];    return longestCommonSubsequence(text1, text2, 0, 0); } private int longestCommonSubsequence(String text1, String text2, int i, int j) {    if (i == text1.length() || j == text2.length())        return 0;    if (dp[i][j] != null)        return dp[i][j];    if (text1.charAt(i) == text2.charAt(j))        return dp[i][j] = 1 + longestCommonSubsequence(text1, text2, i + 1, j + 1);    else        return dp[i][j] = Math.max(        longestCommonSubsequence(text1, text2, i + 1, j),        longestCommonSubsequence(text1, text2, i, j + 1)   ); } 【表依赖】 static int longestCommonSubsequence2(String s1, String s2) {    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0)        return 0;    char[] str1 = s1.toCharArray();    char[] str2 = s2.toCharArray();    int[][] dp = new int[str1.length][str2.length];    dp[0][0] = str1[0] == str2[0] ? 1 : 0;    for (int j = 1; j &lt; str2.length; j++) {        dp[0][j] = (str1[0] == str2[j]) ? 1 : dp[0][j - 1];   }    for (int i = 1; i &lt; str1.length; i++) {        dp[i][0] = (str1[i] == str2[0]) ? 1 : dp[i - 1][0];   }    for (int i = 1; i &lt; str1.length; i++) {        for (int j = 1; j &lt; str2.length; j++) {            if (str1[i] == str2[j]) {                dp[i][j] = 1 + dp[i - 1][j - 1];                continue;           }            dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);       }   }    return dp[str1.length-1][str2.length-1]; } //fixme 第一遍写前面两个for的时候str2.length和str1.length弄反了 最长回文子序列 给定一个字符串str，返回这个宇符串的最长回文子序列长度 比如：str=”a12b3c43def2gh1lkpm” 最长回文子序列是〝1234321” 或者“123c321〞，返回长度7 分析 思路一 str和str逆序串的最长公共子序列就是str的最长回文子序列长度 思路二：范围尝试模型（大概意思就是对一维字符串或其他数组在左、右两个方向都进行尝试，向中间缩小问题规模） str[l]==str[r]时，可以确定当前相同的字符一定会被算入最后的回文子序列，也就是最长的。（对比回文子串） 代码（java） 【暴力递归】 static int longestPalindromeSubseq(String s) {    if (s == null || s.length() == 0) return 0;    char[] str = s.toCharArray();    return process(str, 0, str.length - 1); } //只考虑从L到R到回文子序列长度 static int process(char[] str, int L, int R) {    if (L &gt; R) return 0;    if (L == R)        return str[L] == str[R] ? 1 : 0;    if (str[L] == str[R]) {        return 2 + process(str, L + 1, R - 1);   }    int p1 = process(str, L + 1, R);    int p2 = process(str, L, R - 1);    return Math.max(p1, p2); } 【表依赖】 static int longestPalindromeSubseq(String s) {    if (s == null || s.length() == 0) return 0;    char[] str = s.toCharArray();    int [][]dp = new int[str.length][str.length];    for (int i = 0; i &lt; str.length; i++) {        dp[i][i] = 1;   }    for (int i = str.length-1; i &gt;= 0; i--) {        for (int j = i+1; j &lt; str.length; j++) {            dp[i][j] = str[i] == str[j] ? 2+dp[i+1][j-1]:            Math.max(dp[i+1][j],dp[i][j-1]);       }   }    return dp[0][str.length-1]; } 1-3 表达式求值 分析 解决问题的思想都是要把中缀表达式进行处理，转化成后缀表达式。一种写法是边转化边计算，这种在读中缀表达式过程中就把能计算的算数算完了，没有输出完整的后缀表达式。当然也可以把中缀表达式彻底转化成后缀表达式，然后再计算。 表达式求值问题最关键的三点：两个栈（数字栈、符号栈），数字栈直接压入数字；符号栈中的符号优先级严格递增；输入到反括号计算直到消除对应括号；最后计算直到符号栈空。 如果没有「数字是非负整数」的限制，处理问题会很麻烦。比如3*(-2)这种就很不好处理负号。 代码（c++） 【简化版】 🔵 注意map的初始化方法。 🔵 用map可以使代码更简洁地判断括号的对应。实际上判断操作符的优先级也可以用map。 🔴 一定不要忘记查看栈前先判断一下栈是否为空（具体看代码，这个地方容易错） #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;map&gt; using namespace std; int val[6]; stack&lt;int&gt; num; stack&lt;char&gt; op; map&lt;char,char&gt; rev = { {')', '('},{']','['},{'}','{'} }; // map可以使用这种方式初始化 // priority int pri(char c) { if (c == '+' || c == '-') return 1; if (c == '*' || c == '/' || c =='%') return 2; if (c == '^') return 3; return -1; } int isOp(char c) { return c == '+' || c == '-' ||c == '*' || c == '/' || c =='%'||c == '^'; } int mi(int num1, int num2) { int tmp = num1; for (int i = 0; i &lt; num2 - 1; i++) num1 *= tmp; return num1; } void cal() { int tmp2 = num.top(); num.pop(); int tmp1 = num.top(); num.pop(); char c = op.top(); op.pop(); if (c == '+') num.push(tmp1 + tmp2); else if (c == '-') num.push(tmp1 - tmp2); else if (c == '*') num.push(tmp1 * tmp2); else if (c == '/') num.push(tmp1 / tmp2); else if (c == '%') num.push(tmp1 % tmp2); else if (c == '^') num.push(mi(tmp1, tmp2)); } int main() { string ss; cin &gt;&gt; ss; for (int i = 0; i &lt; 6; i++) cin &gt;&gt; val[i]; //输入a~f for (char c : ss) { if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') { // 表示num num.push(val[c-'a']); } else if (c == '(' || c == '[' || c == '{') { op.push(c); } else if (isOp(c)) { // TODO !这里一定不要忘记先判断一下栈是否为空！！ while (!op.empty() &amp;&amp; pri(op.top()) &gt;= pri(c)) cal(); op.push(c); } else { while (rev[c] != op.top()) cal(); op.pop(); } } while (!op.empty()) cal(); cout &lt;&lt; num.top(); } 1-4 高精度运算模拟 高精度的加减乘除运算模拟"
  },"/week/2024-03-17-week-algorithm-2.html": {
    "title": "数据结构&amp;算法（2）",
    "keywords": "",
    "url": "/week/2024-03-17-week-algorithm-2.html",
    "body": "2-1 分数到小数 2-1 分数到小数 此题是LeetCode原题（同时在华科计算机考研复试也出现过），链接点这里。 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。如果小数部分为循环小数，则将循环的部分括在括号内。如果存在多个答案，只需返回 任意一个 。对于所有给定的输入，保证 答案字符串的长度小于 10^4 。 示例 1： 输入：numerator = 1, denominator = 2 输出：\"0.5\" 示例 2： 输入：numerator = 2, denominator = 1 输出：\"2\" 示例 3： 输入：numerator = 4, denominator = 333 输出：\"0.(012)\" https://leetcode.cn/problems/redundant-connection/ https://leetcode.cn/problems/accounts-merge/description/ 非int数组形式的并查集"
  },"/week/2024-03-19-week-algorithm-3.html": {
    "title": "数据结构&amp;算法（3）",
    "keywords": "",
    "url": "/week/2024-03-19-week-algorithm-3.html",
    "body": "3-0 单调栈和单调队列 3-1 最长递增子序列 排序 3-0 单调栈和单调队列 3-1 最长递增子序列 169. 多数元素 674. 最长连续递增序列 378. 有序矩阵中第 K 小的元素 排序"
  }}
